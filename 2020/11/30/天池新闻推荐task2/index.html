<!DOCTYPE html><html lang="zn-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>天池-新闻推荐之多路召回 | LZMcosmos</title><meta name="author" content="李子梅"><meta name="copyright" content="李子梅"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="天池——新闻推荐之多路召回 多路召回 召回  召回(match)是指从全量信息集合中得到用户可能感兴趣的一小部分候选集。  召回之后是排序，排序是将召回阶段得到的候选集的内容进行打分排序，选出得分高的几个结果推荐给用户。 多路召回 多路召回是指采用不同的策略、特征或者简单模型分别召回一部分候选集，然后将候选集混合在一起供后续的排序模型使用。  导入包 1234567891011">
<meta property="og:type" content="article">
<meta property="og:title" content="天池-新闻推荐之多路召回">
<meta property="og:url" content="https://lzmcosmos.github.io/2020/11/30/%E5%A4%A9%E6%B1%A0%E6%96%B0%E9%97%BB%E6%8E%A8%E8%8D%90task2/index.html">
<meta property="og:site_name" content="LZMcosmos">
<meta property="og:description" content="天池——新闻推荐之多路召回 多路召回 召回  召回(match)是指从全量信息集合中得到用户可能感兴趣的一小部分候选集。  召回之后是排序，排序是将召回阶段得到的候选集的内容进行打分排序，选出得分高的几个结果推荐给用户。 多路召回 多路召回是指采用不同的策略、特征或者简单模型分别召回一部分候选集，然后将候选集混合在一起供后续的排序模型使用。  导入包 1234567891011">
<meta property="og:locale" content="zn_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2020-11-30T14:54:12.000Z">
<meta property="article:modified_time" content="2021-03-19T05:34:21.201Z">
<meta property="article:author" content="李子梅">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/cosmos.jpg"><link rel="canonical" href="https://lzmcosmos.github.io/2020/11/30/%E5%A4%A9%E6%B1%A0%E6%96%B0%E9%97%BB%E6%8E%A8%E8%8D%90task2/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-03-19 13:34:21'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/cosmos.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">89</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">108</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">9</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/Nebula_planets-Universe.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">LZMcosmos</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">天池-新闻推荐之多路召回</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2020-11-30T14:54:12.000Z" title="Created 2020-11-30 22:54:12">2020-11-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-03-19T05:34:21.201Z" title="Updated 2021-03-19 13:34:21">2021-03-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/">推荐系统</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="天池新闻推荐之多路召回">天池——新闻推荐之多路召回</h1>
<h2 id="多路召回">多路召回</h2>
<h3 id="召回">召回</h3>
<blockquote>
<p><strong>召回(match)</strong>是指从全量信息集合中得到用户可能感兴趣的一小部分候选集。</p>
</blockquote>
<p>召回之后是<strong>排序</strong>，排序是将召回阶段得到的候选集的内容进行打分排序，选出得分高的几个结果推荐给用户。</p>
<h3 id="多路召回-1">多路召回</h3>
<p>多路召回是指采用不同的策略、特征或者简单模型分别召回一部分候选集，然后将候选集混合在一起供后续的排序模型使用。 <img src="/img/match_sort.png" /></p>
<h3 id="导入包">导入包</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd  </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm  </span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict  </span><br><span class="line"><span class="keyword">import</span> os, math, warnings, math, pickle</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> faiss</span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> deepctr.feature_column <span class="keyword">import</span> SparseFeat, VarLenSparseFeat</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.keras <span class="keyword">import</span> backend <span class="keyword">as</span> K</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.keras.models <span class="keyword">import</span> Model</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.keras.preprocessing.sequence <span class="keyword">import</span> pad_sequences</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> deepmatch.models <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> deepmatch.utils <span class="keyword">import</span> sampledsoftmaxloss</span><br><span class="line">warnings.filterwarnings(<span class="string">&#x27;ignore&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="设置使用的gpu">设置使用的GPU</h3>
<p>(一般不用指定--这里因为我的第一块GPU在跑模型) <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置以下用的gpu</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">&#x27;CUDA_VISIBLE_DEVICES&#x27;</span>]=<span class="string">&#x27;1&#x27;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data_path = <span class="string">&#x27;./raw_data/&#x27;</span></span><br><span class="line">save_path = <span class="string">&#x27;./temp_results/&#x27;</span></span><br><span class="line"><span class="comment"># 做召回评估的一个标志, 如果不进行评估就是直接使用全量数据进行召回</span></span><br><span class="line">metric_recall = <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h2 id="读取数据">读取数据</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># debug模式： 从训练集中划出一部分数据来调试代码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_all_click_sample</span>(<span class="params">data_path, sample_nums=<span class="number">10000</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        训练集中采样一部分数据调试</span></span><br><span class="line"><span class="string">        data_path: 原数据的存储路径</span></span><br><span class="line"><span class="string">        sample_nums: 采样数目（这里由于机器的内存限制，可以采样用户做）</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    all_click = pd.read_csv(data_path + <span class="string">&#x27;train_click_log.csv&#x27;</span>)</span><br><span class="line">    all_user_ids = all_click.user_id.unique()</span><br><span class="line"></span><br><span class="line">    sample_user_ids = np.random.choice(all_user_ids, size=sample_nums, replace=<span class="literal">False</span>) </span><br><span class="line">    all_click = all_click[all_click[<span class="string">&#x27;user_id&#x27;</span>].isin(sample_user_ids)]</span><br><span class="line">    </span><br><span class="line">    all_click = all_click.drop_duplicates(([<span class="string">&#x27;user_id&#x27;</span>, <span class="string">&#x27;click_article_id&#x27;</span>, <span class="string">&#x27;click_timestamp&#x27;</span>]))</span><br><span class="line">    <span class="keyword">return</span> all_click</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取点击数据，这里分成线上和线下，如果是为了获取线上提交结果应该讲测试集中的点击数据合并到总的数据中</span></span><br><span class="line"><span class="comment"># 如果是为了线下验证模型的有效性或者特征的有效性，可以只使用训练集</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_all_click_df</span>(<span class="params">data_path=<span class="string">&#x27;./raw_data/&#x27;</span>, offline=<span class="literal">True</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> offline:</span><br><span class="line">        all_click = pd.read_csv(data_path + <span class="string">&#x27;train_click_log.csv&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        trn_click = pd.read_csv(data_path + <span class="string">&#x27;train_click_log.csv&#x27;</span>)</span><br><span class="line">        tst_click = pd.read_csv(data_path + <span class="string">&#x27;testA_click_log.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        all_click = trn_click.append(tst_click)</span><br><span class="line">    </span><br><span class="line">    all_click = all_click.drop_duplicates(([<span class="string">&#x27;user_id&#x27;</span>, <span class="string">&#x27;click_article_id&#x27;</span>, <span class="string">&#x27;click_timestamp&#x27;</span>]))</span><br><span class="line">    <span class="keyword">return</span> all_click</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取文章的基本属性</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_item_info_df</span>(<span class="params">data_path</span>):</span></span><br><span class="line">    item_info_df = pd.read_csv(data_path + <span class="string">&#x27;articles.csv&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 为了方便与训练集中的click_article_id拼接，需要把article_id修改成click_article_id</span></span><br><span class="line">    item_info_df = item_info_df.rename(columns=&#123;<span class="string">&#x27;article_id&#x27;</span>: <span class="string">&#x27;click_article_id&#x27;</span>&#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> item_info_df</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取文章的Embedding数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_item_emb_dict</span>(<span class="params">data_path</span>):</span></span><br><span class="line">    item_emb_df = pd.read_csv(data_path + <span class="string">&#x27;articles_emb.csv&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    item_emb_cols = [x <span class="keyword">for</span> x <span class="keyword">in</span> item_emb_df.columns <span class="keyword">if</span> <span class="string">&#x27;emb&#x27;</span> <span class="keyword">in</span> x]</span><br><span class="line">    item_emb_np = np.ascontiguousarray(item_emb_df[item_emb_cols])</span><br><span class="line">    <span class="comment"># 进行归一化</span></span><br><span class="line">    item_emb_np = item_emb_np / np.linalg.norm(item_emb_np, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    item_emb_dict = <span class="built_in">dict</span>(<span class="built_in">zip</span>(item_emb_df[<span class="string">&#x27;article_id&#x27;</span>], item_emb_np))</span><br><span class="line">    pickle.dump(item_emb_dict, <span class="built_in">open</span>(save_path + <span class="string">&#x27;item_content_emb.pkl&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> item_emb_dict</span><br></pre></td></tr></table></figure>
<h3 id="minmaxscaler">MinMaxScaler</h3>
<p>将特征缩放至特定区域，即给定的最小值和最大值之间。 &gt; 对原始数据进行线性变换，将数据缩放到[0,1]之间。 * 缺陷：新数据加入时可能导致max和min的变化，需要重新计算。注意，异常值会十分影响max或min，所以它适用于数据在一个范围内分布的情况。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max_min_scaler = <span class="keyword">lambda</span> x : (x-np.<span class="built_in">min</span>(x))/(np.<span class="built_in">max</span>(x)-np.<span class="built_in">min</span>(x))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 采样数据</span></span><br><span class="line"><span class="comment"># all_click_df = get_all_click_sample(data_path)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 全量训练集</span></span><br><span class="line">all_click_df = get_all_click_df(offline=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对时间戳进行归一化,用于在关联规则的时候计算权重</span></span><br><span class="line">all_click_df[<span class="string">&#x27;click_timestamp&#x27;</span>] = all_click_df[[<span class="string">&#x27;click_timestamp&#x27;</span>]].apply(max_min_scaler)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">item_info_df = get_item_info_df(data_path)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">item_emb_dict = get_item_emb_dict(data_path)</span><br></pre></td></tr></table></figure>
<h2 id="工具函数">工具函数</h2>
<h3 id="获取用户-文章-时间函数">获取用户-文章-时间函数</h3>
<p>这个在基于关联规则的<strong>用户协同过滤</strong>的时候会用到。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据点击时间获取用户的点击文章序列   &#123;user1: [(item1, time1), (item2, time2)..]...&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_user_item_time</span>(<span class="params">click_df</span>):</span></span><br><span class="line">    </span><br><span class="line">    click_df = click_df.sort_values(<span class="string">&#x27;click_timestamp&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_item_time_pair</span>(<span class="params">df</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">zip</span>(df[<span class="string">&#x27;click_article_id&#x27;</span>], df[<span class="string">&#x27;click_timestamp&#x27;</span>]))</span><br><span class="line">    </span><br><span class="line">    user_item_time_df = click_df.groupby(<span class="string">&#x27;user_id&#x27;</span>)[<span class="string">&#x27;click_article_id&#x27;</span>, <span class="string">&#x27;click_timestamp&#x27;</span>].apply(<span class="keyword">lambda</span> x: make_item_time_pair(x))\</span><br><span class="line">                                                            .reset_index().rename(columns=&#123;<span class="number">0</span>: <span class="string">&#x27;item_time_list&#x27;</span>&#125;)</span><br><span class="line">    user_item_time_dict = <span class="built_in">dict</span>(<span class="built_in">zip</span>(user_item_time_df[<span class="string">&#x27;user_id&#x27;</span>], user_item_time_df[<span class="string">&#x27;item_time_list&#x27;</span>]))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> user_item_time_dict</span><br></pre></td></tr></table></figure>
<h3 id="获取文章-用户-时间函数">获取文章-用户-时间函数</h3>
<p>这个在基于关联规则的<strong>文章协同过滤</strong>的时候会用到。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据时间获取商品被点击的用户序列  &#123;item1: [(user1, time1), (user2, time2)...]...&#125;</span></span><br><span class="line"><span class="comment"># 这里的时间是用户点击当前商品的时间，好像没有直接的关系。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_item_user_time_dict</span>(<span class="params">click_df</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_user_time_pair</span>(<span class="params">df</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">zip</span>(df[<span class="string">&#x27;user_id&#x27;</span>], df[<span class="string">&#x27;click_timestamp&#x27;</span>]))</span><br><span class="line">    </span><br><span class="line">    click_df = click_df.sort_values(<span class="string">&#x27;click_timestamp&#x27;</span>)</span><br><span class="line">    item_user_time_df = click_df.groupby(<span class="string">&#x27;click_article_id&#x27;</span>)[<span class="string">&#x27;user_id&#x27;</span>, <span class="string">&#x27;click_timestamp&#x27;</span>].apply(<span class="keyword">lambda</span> x: make_user_time_pair(x))\</span><br><span class="line">                                                            .reset_index().rename(columns=&#123;<span class="number">0</span>: <span class="string">&#x27;user_time_list&#x27;</span>&#125;)</span><br><span class="line">    </span><br><span class="line">    item_user_time_dict = <span class="built_in">dict</span>(<span class="built_in">zip</span>(item_user_time_df[<span class="string">&#x27;click_article_id&#x27;</span>], item_user_time_df[<span class="string">&#x27;user_time_list&#x27;</span>]))</span><br><span class="line">    <span class="keyword">return</span> item_user_time_dict</span><br></pre></td></tr></table></figure>
<h2 id="获取历史和最后一次点击">获取历史和最后一次点击</h2>
<p>这个在评估召回结果、特征工程和制作标签转成监督学习测试集的时候回用到</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取当前数据的历史点击和最后一次点击</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_hist_and_last_click</span>(<span class="params">all_click</span>):</span></span><br><span class="line">    all_click = all_click.sort_values(by=[<span class="string">&#x27;user_id&#x27;</span>,<span class="string">&#x27;click_timestamp&#x27;</span>])</span><br><span class="line">    click_last_df = all_click.groupby(<span class="string">&#x27;user_id&#x27;</span>).tail(<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 如果用户只有一个点击，hist为空了，会导致训练的时候这个用户不可见，此时默认泄露一下</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hist_func</span>(<span class="params">user_df</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(user_df) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> user_df</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> user_df[:-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    click_hist_df = all_click.groupby(<span class="string">&#x27;user_id&#x27;</span>).apply(hist_func).reset_index(drop=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> click_hist_df, click_last_df</span><br></pre></td></tr></table></figure>
<h3 id="获取文章属性特征">获取文章属性特征</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取文章id对应的基本属性，保存成字典的形式，方便后面召回阶段，冷启动阶段直接使用</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_item_info_dict</span>(<span class="params">item_info_df</span>):</span></span><br><span class="line">    max_min_scaler = <span class="keyword">lambda</span> x: (x - np.<span class="built_in">min</span>(x))/(np.<span class="built_in">max</span>(x) - np.<span class="built_in">min</span>(x))</span><br><span class="line">    item_info_df[<span class="string">&#x27;created_at_ts&#x27;</span>] = item_info_df[[<span class="string">&#x27;created_at_ts&#x27;</span>]].apply(max_min_scaler)</span><br><span class="line">    </span><br><span class="line">    item_type_dict = <span class="built_in">dict</span>(<span class="built_in">zip</span>(item_info_df[<span class="string">&#x27;click_article_id&#x27;</span>], item_info_df[<span class="string">&#x27;category_id&#x27;</span>]))</span><br><span class="line">    item_words_dict = <span class="built_in">dict</span>(<span class="built_in">zip</span>(item_info_df[<span class="string">&#x27;click_article_id&#x27;</span>], item_info_df[<span class="string">&#x27;words_count&#x27;</span>]))</span><br><span class="line">    item_created_time_dict = <span class="built_in">dict</span>(<span class="built_in">zip</span>(item_info_df[<span class="string">&#x27;click_article_id&#x27;</span>], item_info_df[<span class="string">&#x27;created_at_ts&#x27;</span>]))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> item_type_dict, item_words_dict, item_created_time_dict</span><br></pre></td></tr></table></figure>
<h3 id="获取用户历史点击的文章信息">获取用户历史点击的文章信息</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_user_hist_item_info_dict</span>(<span class="params">all_click</span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取user_id对应的用户历史点击文章类型的集合字典</span></span><br><span class="line">    user_hist_item_typs = all_click.groupby(<span class="string">&#x27;user_id&#x27;</span>)[<span class="string">&#x27;category_id&#x27;</span>].agg(<span class="built_in">set</span>).reset_index()</span><br><span class="line">    user_hist_item_typs_dict = <span class="built_in">dict</span>(<span class="built_in">zip</span>(user_hist_item_typs[<span class="string">&#x27;user_id&#x27;</span>], user_hist_item_typs[<span class="string">&#x27;category_id&#x27;</span>]))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取user_id对应的用户点击文章的集合</span></span><br><span class="line">    user_hist_item_ids_dict = all_click.groupby(<span class="string">&#x27;user_id&#x27;</span>)[<span class="string">&#x27;click_article_id&#x27;</span>].agg(<span class="built_in">set</span>).reset_index()</span><br><span class="line">    user_hist_item_ids_dict = <span class="built_in">dict</span>(<span class="built_in">zip</span>(user_hist_item_ids_dict[<span class="string">&#x27;user_id&#x27;</span>], user_hist_item_ids_dict[<span class="string">&#x27;click_article_id&#x27;</span>]))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取user_id对应的用户历史点击的文章的平均字数字典</span></span><br><span class="line">    user_hist_item_words = all_click.groupby(<span class="string">&#x27;user_id&#x27;</span>)[<span class="string">&#x27;words_count&#x27;</span>].agg(<span class="string">&#x27;mean&#x27;</span>).reset_index()</span><br><span class="line">    user_hist_item_words_dict = <span class="built_in">dict</span>(<span class="built_in">zip</span>(user_hist_item_words[<span class="string">&#x27;user_id&#x27;</span>], user_hist_item_words[<span class="string">&#x27;words_count&#x27;</span>]))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取user_id对应的用户最后一次点击的文章的创建时间</span></span><br><span class="line">    all_click_ = all_click.sort_values(<span class="string">&#x27;click_timestamp&#x27;</span>)</span><br><span class="line">    user_last_item_created_time = all_click_.groupby(<span class="string">&#x27;user_id&#x27;</span>)[<span class="string">&#x27;created_at_ts&#x27;</span>].apply(<span class="keyword">lambda</span> x: x.iloc[-<span class="number">1</span>]).reset_index()</span><br><span class="line">    </span><br><span class="line">    max_min_scaler = <span class="keyword">lambda</span> x : (x-np.<span class="built_in">min</span>(x))/(np.<span class="built_in">max</span>(x)-np.<span class="built_in">min</span>(x))</span><br><span class="line">    user_last_item_created_time[<span class="string">&#x27;created_at_ts&#x27;</span>] = user_last_item_created_time[[<span class="string">&#x27;created_at_ts&#x27;</span>]].apply(max_min_scaler)</span><br><span class="line">    </span><br><span class="line">    user_last_item_created_time_dict = <span class="built_in">dict</span>(<span class="built_in">zip</span>(user_last_item_created_time[<span class="string">&#x27;user_id&#x27;</span>], \</span><br><span class="line">                                                user_last_item_created_time[<span class="string">&#x27;created_at_ts&#x27;</span>]))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> user_hist_item_typs_dict, user_hist_item_ids_dict, user_hist_item_words_dict, user_last_item_created_time_dict</span><br></pre></td></tr></table></figure>
<h3 id="获取点击次数最多的topk个文章">获取点击次数最多的topk个文章</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取近期点击最多的文章</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_item_topk_click</span>(<span class="params">click_df, k</span>):</span></span><br><span class="line">    topk_click = click_df[<span class="string">&#x27;click_article_id&#x27;</span>].value_counts().index[:k]</span><br><span class="line">    <span class="keyword">return</span> topk_click</span><br></pre></td></tr></table></figure>
<h3 id="定义多路召回字典">定义多路召回字典</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取文章的属性信息，保存成字典的形式方便查询</span></span><br><span class="line">item_type_dict, item_words_dict, item_created_time_dict = get_item_info_dict(item_info_df)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个多路召回的字典，将各路召回的结果都保存在这个字典当中</span></span><br><span class="line">user_multi_recall_dict =  &#123;<span class="string">&#x27;itemcf_sim_itemcf_recall&#x27;</span>: &#123;&#125;,</span><br><span class="line">                           <span class="string">&#x27;embedding_sim_item_recall&#x27;</span>: &#123;&#125;,</span><br><span class="line">                           <span class="string">&#x27;youtubednn_recall&#x27;</span>: &#123;&#125;,</span><br><span class="line">                           <span class="string">&#x27;youtubednn_usercf_recall&#x27;</span>: &#123;&#125;, </span><br><span class="line">                           <span class="string">&#x27;cold_start_recall&#x27;</span>: &#123;&#125;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提取最后一次点击作为召回评估，如果不需要做召回评估直接使用全量的训练集进行召回(线下验证模型)</span></span><br><span class="line"><span class="comment"># 如果不是召回评估，直接使用全量数据进行召回，不用将最后一次提取出来</span></span><br><span class="line">trn_hist_click_df, trn_last_click_df = get_hist_and_last_click(all_click_df)</span><br></pre></td></tr></table></figure>
<h3 id="召回效果评估函数">召回效果评估函数</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">metrics_recall</span>(<span class="params">user_recall_items_dict, trn_last_click_df, topk=<span class="number">5</span></span>):</span></span><br><span class="line">    last_click_item_dict = <span class="built_in">dict</span>(<span class="built_in">zip</span>(trn_last_click_df[<span class="string">&#x27;user_id&#x27;</span>], trn_last_click_df[<span class="string">&#x27;click_article_id&#x27;</span>]))</span><br><span class="line">    user_num = <span class="built_in">len</span>(user_recall_items_dict)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>, topk+<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">        hit_num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> user, item_list <span class="keyword">in</span> user_recall_items_dict.items():</span><br><span class="line">            <span class="comment"># 获取前k个召回的结果</span></span><br><span class="line">            tmp_recall_items = [x[<span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> user_recall_items_dict[user][:k]]</span><br><span class="line">            <span class="keyword">if</span> last_click_item_dict[user] <span class="keyword">in</span> <span class="built_in">set</span>(tmp_recall_items):</span><br><span class="line">                hit_num += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        hit_rate = <span class="built_in">round</span>(hit_num * <span class="number">1.0</span> / user_num, <span class="number">5</span>)</span><br><span class="line">        print(<span class="string">&#x27; topk: &#x27;</span>, k, <span class="string">&#x27; : &#x27;</span>, <span class="string">&#x27;hit_num: &#x27;</span>, hit_num, <span class="string">&#x27;hit_rate: &#x27;</span>, hit_rate, <span class="string">&#x27;user_num : &#x27;</span>, user_num)</span><br></pre></td></tr></table></figure>
<h2 id="计算相似性矩阵">计算相似性矩阵</h2>
<p>这一部分主要是通过协同过滤以及向量检索得到相似性矩阵，相似性矩阵主要分为user2user和item2item，下面依次获取基于itemcf的item2item的相似性矩阵： ### itemcf i2i_sim</p>
<p>借鉴KDD2020的去偏商品推荐，在计算item2item相似性矩阵时，使用关联规则，使得计算的文章的相似性还考虑到了: * 用户点击的时间权重 * 用户点击的顺序权重 * 文章创建的时间权重</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">itemcf_sim</span>(<span class="params">df, item_created_time_dict</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        文章与文章之间的相似性矩阵计算</span></span><br><span class="line"><span class="string">        :param df: 数据表</span></span><br><span class="line"><span class="string">        :item_created_time_dict:  文章创建时间的字典</span></span><br><span class="line"><span class="string">        return : 文章与文章的相似性矩阵</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        思路: 基于物品的协同过滤(详细请参考上一期推荐系统基础的组队学习) + 关联规则</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    user_item_time_dict = get_user_item_time(df)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算物品相似度</span></span><br><span class="line">    i2i_sim = &#123;&#125;</span><br><span class="line">    item_cnt = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">    <span class="keyword">for</span> user, item_time_list <span class="keyword">in</span> tqdm(user_item_time_dict.items()):</span><br><span class="line">        <span class="comment"># 在基于商品的协同过滤优化的时候可以考虑时间因素</span></span><br><span class="line">        <span class="keyword">for</span> loc1, (i, i_click_time) <span class="keyword">in</span> <span class="built_in">enumerate</span>(item_time_list):</span><br><span class="line">            item_cnt[i] += <span class="number">1</span></span><br><span class="line">            i2i_sim.setdefault(i, &#123;&#125;)</span><br><span class="line">            <span class="keyword">for</span> loc2, (j, j_click_time) <span class="keyword">in</span> <span class="built_in">enumerate</span>(item_time_list):</span><br><span class="line">                <span class="keyword">if</span>(i == j):</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                    </span><br><span class="line">                <span class="comment"># 考虑文章的正向顺序点击和反向顺序点击    </span></span><br><span class="line">                loc_alpha = <span class="number">1.0</span> <span class="keyword">if</span> loc2 &gt; loc1 <span class="keyword">else</span> <span class="number">0.7</span></span><br><span class="line">                <span class="comment"># 位置信息权重，其中的参数可以调节</span></span><br><span class="line">                loc_weight = loc_alpha * (<span class="number">0.9</span> ** (np.<span class="built_in">abs</span>(loc2 - loc1) - <span class="number">1</span>))</span><br><span class="line">                <span class="comment"># 点击时间权重，其中的参数可以调节</span></span><br><span class="line">                click_time_weight = np.exp(<span class="number">0.7</span> ** np.<span class="built_in">abs</span>(i_click_time - j_click_time))</span><br><span class="line">                <span class="comment"># 两篇文章创建时间的权重，其中的参数可以调节</span></span><br><span class="line">                created_time_weight = np.exp(<span class="number">0.8</span> ** np.<span class="built_in">abs</span>(item_created_time_dict[i] - item_created_time_dict[j]))</span><br><span class="line">                i2i_sim[i].setdefault(j, <span class="number">0</span>)</span><br><span class="line">                <span class="comment"># 考虑多种因素的权重计算最终的文章之间的相似度</span></span><br><span class="line">                i2i_sim[i][j] += loc_weight * click_time_weight * created_time_weight / math.log(<span class="built_in">len</span>(item_time_list) + <span class="number">1</span>)</span><br><span class="line">                </span><br><span class="line">    i2i_sim_ = i2i_sim.copy()</span><br><span class="line">    <span class="keyword">for</span> i, related_items <span class="keyword">in</span> i2i_sim.items():</span><br><span class="line">        <span class="keyword">for</span> j, wij <span class="keyword">in</span> related_items.items():</span><br><span class="line">            i2i_sim_[i][j] = wij / math.sqrt(item_cnt[i] * item_cnt[j])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将得到的相似性矩阵保存到本地</span></span><br><span class="line">    pickle.dump(i2i_sim_, <span class="built_in">open</span>(save_path + <span class="string">&#x27;itemcf_i2i_sim.pkl&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> i2i_sim_</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i2i_sim = itemcf_sim(all_click_df, item_created_time_dict)</span><br></pre></td></tr></table></figure>
<pre><code>100%|██████████| 250000/250000 [03:33&lt;00:00, 1170.07it/s]</code></pre>
<h3 id="usercf-u2u_sim">usercf u2u_sim</h3>
<p>在计算用户之间的相似度的时候，也可以使用一些简单的关联规则，比如用户活跃度权重，这里将用户的点击次数作为用户活跃度的指标</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_user_activate_degree_dict</span>(<span class="params">all_click_df</span>):</span></span><br><span class="line">    all_click_df_ = all_click_df.groupby(<span class="string">&#x27;user_id&#x27;</span>)[<span class="string">&#x27;click_article_id&#x27;</span>].count().reset_index()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 用户活跃度归一化</span></span><br><span class="line">    mm = MinMaxScaler()</span><br><span class="line">    all_click_df_[<span class="string">&#x27;click_article_id&#x27;</span>] = mm.fit_transform(all_click_df_[[<span class="string">&#x27;click_article_id&#x27;</span>]])</span><br><span class="line">    user_activate_degree_dict = <span class="built_in">dict</span>(<span class="built_in">zip</span>(all_click_df_[<span class="string">&#x27;user_id&#x27;</span>], all_click_df_[<span class="string">&#x27;click_article_id&#x27;</span>]))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> user_activate_degree_dict</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">usercf_sim</span>(<span class="params">all_click_df, user_activate_degree_dict</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        用户相似性矩阵计算</span></span><br><span class="line"><span class="string">        :param all_click_df: 数据表</span></span><br><span class="line"><span class="string">        :param user_activate_degree_dict: 用户活跃度的字典</span></span><br><span class="line"><span class="string">        return 用户相似性矩阵</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        思路: 基于用户的协同过滤(详细请参考上一期推荐系统基础的组队学习) + 关联规则</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    item_user_time_dict = get_item_user_time_dict(all_click_df)</span><br><span class="line">    </span><br><span class="line">    u2u_sim = &#123;&#125;</span><br><span class="line">    user_cnt = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">    <span class="keyword">for</span> item, user_time_list <span class="keyword">in</span> tqdm(item_user_time_dict.items()):</span><br><span class="line">        <span class="keyword">for</span> u, click_time <span class="keyword">in</span> user_time_list:</span><br><span class="line">            user_cnt[u] += <span class="number">1</span></span><br><span class="line">            u2u_sim.setdefault(u, &#123;&#125;)</span><br><span class="line">            <span class="keyword">for</span> v, click_time <span class="keyword">in</span> user_time_list:</span><br><span class="line">                u2u_sim[u].setdefault(v, <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> u == v:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 用户平均活跃度作为活跃度的权重，这里的式子也可以改善</span></span><br><span class="line">                activate_weight = <span class="number">100</span> * <span class="number">0.5</span> * (user_activate_degree_dict[u] + user_activate_degree_dict[v])   </span><br><span class="line">                u2u_sim[u][v] += activate_weight / math.log(<span class="built_in">len</span>(user_time_list) + <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    u2u_sim_ = u2u_sim.copy()</span><br><span class="line">    <span class="keyword">for</span> u, related_users <span class="keyword">in</span> u2u_sim.items():</span><br><span class="line">        <span class="keyword">for</span> v, wij <span class="keyword">in</span> related_users.items():</span><br><span class="line">            u2u_sim_[u][v] = wij / math.sqrt(user_cnt[u] * user_cnt[v])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将得到的相似性矩阵保存到本地</span></span><br><span class="line">    pickle.dump(u2u_sim_, <span class="built_in">open</span>(save_path + <span class="string">&#x27;usercf_u2u_sim.pkl&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> u2u_sim_</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 由于usercf计算时候太耗费内存了，这里就不直接运行了</span></span><br><span class="line"><span class="comment"># 如果是采样的话，是可以运行的</span></span><br><span class="line">user_activate_degree_dict = get_user_activate_degree_dict(all_click_df)</span><br><span class="line">u2u_sim = usercf_sim(all_click_df, user_activate_degree_dict)</span><br></pre></td></tr></table></figure>
<h3 id="item-embedding-sim">item embedding sim</h3>
<p>使用Embedding计算item之间的相似度是为了后续冷启动的时候可以获取未出现在点击数据中的文章，后面有对冷启动专门的介绍，这里简单的说一下faiss。</p>
<p>faiss是Facebook的AI团队开源的一套用于做聚类或者相似性搜索的软件库，底层是用C++实现。Faiss因为超级优越的性能，被广泛应用于推荐相关的业务当中.</p>
<p><strong>faiss工具包一般使用在推荐系统中的向量召回部分</strong>。在做向量召回的时候要么是u2u,u2i或者i2i，这里的u和i指的是user和item.我们知道在实际的场景中user和item的数量都是海量的，我们最容易想到的基于向量相似度的召回就是使用两层循环遍历user列表或者item列表计算两个向量的相似度，但是这样做在面对海量数据是不切实际的，faiss就是用来加速计算某个查询向量最相似的topk个索引向量。</p>
<h4 id="faiss查询的原理">faiss查询的原理：</h4>
<p>faiss使用了PCA和PQ(Product quantization乘积量化)两种技术进行向量压缩和编码，当然还使用了其他的技术进行优化，但是PCA和PQ是其中最核心部分。</p>
<ul>
<li><p>PCA降维算法细节:<a target="_blank" rel="noopener" href="https://www.cnblogs.com/pinard/p/6239403.html">主成分分析（PCA）原理总结</a></p></li>
<li><p>PQ编码的细节:<a target="_blank" rel="noopener" href="http://www.fabwrite.com/productquantization">实例理解product quantization算法</a></p></li>
</ul>
<h4 id="faiss使用">faiss使用</h4>
<p><a target="_blank" rel="noopener" href="https://github.com/facebookresearch/faiss/wiki/Getting-started">faiss官方教程</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 向量检索相似度计算</span></span><br><span class="line"><span class="comment"># topk指的是每个item, faiss搜索后返回最相似的topk个item</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">embdding_sim</span>(<span class="params">click_df, item_emb_df, save_path, topk</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        基于内容的文章embedding相似性矩阵计算</span></span><br><span class="line"><span class="string">        :param click_df: 数据表</span></span><br><span class="line"><span class="string">        :param item_emb_df: 文章的embedding</span></span><br><span class="line"><span class="string">        :param save_path: 保存路径</span></span><br><span class="line"><span class="string">        :patam topk: 找最相似的topk篇</span></span><br><span class="line"><span class="string">        return 文章相似性矩阵</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        思路: 对于每一篇文章， 基于embedding的相似性返回topk个与其最相似的文章， 只不过由于文章数量太多，这里用了faiss进行加速</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 文章索引与文章id的字典映射</span></span><br><span class="line">    item_idx_2_rawid_dict = <span class="built_in">dict</span>(<span class="built_in">zip</span>(item_emb_df.index, item_emb_df[<span class="string">&#x27;article_id&#x27;</span>]))</span><br><span class="line">    </span><br><span class="line">    item_emb_cols = [x <span class="keyword">for</span> x <span class="keyword">in</span> item_emb_df.columns <span class="keyword">if</span> <span class="string">&#x27;emb&#x27;</span> <span class="keyword">in</span> x]</span><br><span class="line">    item_emb_np = np.ascontiguousarray(item_emb_df[item_emb_cols].values, dtype=np.float32)</span><br><span class="line">    <span class="comment"># 向量进行单位化</span></span><br><span class="line">    item_emb_np = item_emb_np / np.linalg.norm(item_emb_np, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 建立faiss索引</span></span><br><span class="line">    item_index = faiss.IndexFlatIP(item_emb_np.shape[<span class="number">1</span>])</span><br><span class="line">    item_index.add(item_emb_np)</span><br><span class="line">    <span class="comment"># 相似度查询，给每个索引位置上的向量返回topk个item以及相似度</span></span><br><span class="line">    sim, idx = item_index.search(item_emb_np, topk) <span class="comment"># 返回的是列表</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将向量检索的结果保存成原始id的对应关系</span></span><br><span class="line">    item_sim_dict = collections.defaultdict(<span class="built_in">dict</span>)</span><br><span class="line">    <span class="keyword">for</span> target_idx, sim_value_list, rele_idx_list <span class="keyword">in</span> tqdm(<span class="built_in">zip</span>(<span class="built_in">range</span>(<span class="built_in">len</span>(item_emb_np)), sim, idx)):</span><br><span class="line">        target_raw_id = item_idx_2_rawid_dict[target_idx]</span><br><span class="line">        <span class="comment"># 从1开始是为了去掉商品本身, 所以最终获得的相似商品只有topk-1</span></span><br><span class="line">        <span class="keyword">for</span> rele_idx, sim_value <span class="keyword">in</span> <span class="built_in">zip</span>(rele_idx_list[<span class="number">1</span>:], sim_value_list[<span class="number">1</span>:]): </span><br><span class="line">            rele_raw_id = item_idx_2_rawid_dict[rele_idx]</span><br><span class="line">            item_sim_dict[target_raw_id][rele_raw_id] = item_sim_dict.get(target_raw_id, &#123;&#125;).get(rele_raw_id, <span class="number">0</span>) + sim_value</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 保存i2i相似度矩阵</span></span><br><span class="line">    pickle.dump(item_sim_dict, <span class="built_in">open</span>(save_path + <span class="string">&#x27;emb_i2i_sim.pkl&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>))   </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> item_sim_dict</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">item_emb_df = pd.read_csv(data_path + <span class="string">&#x27;/articles_emb.csv&#x27;</span>)</span><br><span class="line">emb_i2i_sim = embdding_sim(all_click_df, item_emb_df, save_path, topk=<span class="number">10</span>) <span class="comment"># topk可以自行设置</span></span><br></pre></td></tr></table></figure>
<pre><code>364047it [00:07, 48168.52it/s]</code></pre>
<h2 id="召回-1">召回</h2>
<p>召回常用的策略： * Youtube DNN 召回 * 基于文章的召回 - 文章的协同过滤 - 基于文章embedding的召回 * 基于用户的召回 - 用户的协同过滤 - 用户embedding</p>
<p>上面的各种召回方式一部分在基于用户已经看得文章的基础上去召回与这些文章相似的一些文章， 而这个相似性的计算方式不同， 就得到了不同的召回方式， 比如文章的协同过滤， 文章内容的embedding等。还有一部分是根据用户的相似性进行推荐，对于某用户推荐与其相似的其他用户看过的文章，比如用户的协同过滤和用户embedding。 还有一种思路是类似矩阵分解的思路，先计算出用户和文章的embedding之后，就可以直接算用户和文章的相似度， 根据这个相似度进行推荐， 比如YouTube DNN。</p>
<h3 id="youtubednn召回">YoutubeDNN召回</h3>
<p>(这一步是直接获取用户召回的候选文章列表)</p>
<p><a target="_blank" rel="noopener" href="https://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/45530.pdf">论文下载地址</a></p>
<h4 id="youtubednn召回架构">Youtubednn召回架构</h4>
<p><img src="/img/youtubednn.png" /></p>
<p>关于YoutubeDNN原理和应用推荐看王喆的两篇博客： * <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/52169807">重读Youtube深度学习推荐系统论文，字字珠玑，惊为神文</a> * <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/52504407">YouTube深度学习推荐系统的十大工程问题</a></p>
<p>参考文献:</p>
<pre><code>https://zhuanlan.zhihu.com/p/52169807 (YouTubeDNN原理)
https://zhuanlan.zhihu.com/p/26306795 (Word2Vec知乎众赞文章) --- word2vec放到排序中的w2v的介绍部分</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取双塔召回时的训练验证数据</span></span><br><span class="line"><span class="comment"># negsample指的是通过滑窗构建样本的时候，负样本的数量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_data_set</span>(<span class="params">data, negsample=<span class="number">0</span></span>):</span></span><br><span class="line">    data.sort_values(<span class="string">&quot;click_timestamp&quot;</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">    item_ids = data[<span class="string">&#x27;click_article_id&#x27;</span>].unique()</span><br><span class="line"></span><br><span class="line">    train_set = []</span><br><span class="line">    test_set = []</span><br><span class="line">    <span class="keyword">for</span> reviewerID, hist <span class="keyword">in</span> tqdm(data.groupby(<span class="string">&#x27;user_id&#x27;</span>)):</span><br><span class="line">        pos_list = hist[<span class="string">&#x27;click_article_id&#x27;</span>].tolist()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> negsample &gt; <span class="number">0</span>:</span><br><span class="line">            candidate_set = <span class="built_in">list</span>(<span class="built_in">set</span>(item_ids) - <span class="built_in">set</span>(pos_list))   <span class="comment"># 用户没看过的文章里面选择负样本</span></span><br><span class="line">            neg_list = np.random.choice(candidate_set,size=<span class="built_in">len</span>(pos_list)*negsample,replace=<span class="literal">True</span>)  <span class="comment"># 对于每个正样本，选择n个负样本</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 长度只有一个的时候，需要把这条数据也放到训练集中，不然的话最终学到的embedding就会有缺失</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(pos_list) == <span class="number">1</span>:</span><br><span class="line">            train_set.append((reviewerID, [pos_list[<span class="number">0</span>]], pos_list[<span class="number">0</span>],<span class="number">1</span>,<span class="built_in">len</span>(pos_list)))</span><br><span class="line">            test_set.append((reviewerID, [pos_list[<span class="number">0</span>]], pos_list[<span class="number">0</span>],<span class="number">1</span>,<span class="built_in">len</span>(pos_list)))</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 滑窗构造正负样本</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(pos_list)):</span><br><span class="line">            hist = pos_list[:i]</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> i != <span class="built_in">len</span>(pos_list) - <span class="number">1</span>:</span><br><span class="line">                train_set.append((reviewerID, hist[::-<span class="number">1</span>], pos_list[i], <span class="number">1</span>, <span class="built_in">len</span>(hist[::-<span class="number">1</span>])))  <span class="comment"># 正样本 [user_id, his_item, pos_item, label, len(his_item)]</span></span><br><span class="line">                <span class="keyword">for</span> negi <span class="keyword">in</span> <span class="built_in">range</span>(negsample):</span><br><span class="line">                    train_set.append((reviewerID, hist[::-<span class="number">1</span>], neg_list[i*negsample+negi], <span class="number">0</span>,<span class="built_in">len</span>(hist[::-<span class="number">1</span>]))) <span class="comment"># 负样本 [user_id, his_item, neg_item, label, len(his_item)]</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 将最长的那一个序列长度作为测试数据</span></span><br><span class="line">                test_set.append((reviewerID, hist[::-<span class="number">1</span>], pos_list[i],<span class="number">1</span>,<span class="built_in">len</span>(hist[::-<span class="number">1</span>])))</span><br><span class="line">                </span><br><span class="line">    random.shuffle(train_set)</span><br><span class="line">    random.shuffle(test_set)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> train_set, test_set</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将输入的数据进行padding，使得序列特征的长度都一致</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_model_input</span>(<span class="params">train_set,user_profile,seq_max_len</span>):</span></span><br><span class="line"></span><br><span class="line">    train_uid = np.array([line[<span class="number">0</span>] <span class="keyword">for</span> line <span class="keyword">in</span> train_set])</span><br><span class="line">    train_seq = [line[<span class="number">1</span>] <span class="keyword">for</span> line <span class="keyword">in</span> train_set]</span><br><span class="line">    train_iid = np.array([line[<span class="number">2</span>] <span class="keyword">for</span> line <span class="keyword">in</span> train_set])</span><br><span class="line">    train_label = np.array([line[<span class="number">3</span>] <span class="keyword">for</span> line <span class="keyword">in</span> train_set])</span><br><span class="line">    train_hist_len = np.array([line[<span class="number">4</span>] <span class="keyword">for</span> line <span class="keyword">in</span> train_set])</span><br><span class="line"></span><br><span class="line">    train_seq_pad = pad_sequences(train_seq, maxlen=seq_max_len, padding=<span class="string">&#x27;post&#x27;</span>, truncating=<span class="string">&#x27;post&#x27;</span>, value=<span class="number">0</span>)</span><br><span class="line">    train_model_input = &#123;<span class="string">&quot;user_id&quot;</span>: train_uid, <span class="string">&quot;click_article_id&quot;</span>: train_iid, <span class="string">&quot;hist_article_id&quot;</span>: train_seq_pad,</span><br><span class="line">                         <span class="string">&quot;hist_len&quot;</span>: train_hist_len&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> train_model_input, train_label</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">youtubednn_u2i_dict</span>(<span class="params">data, topk=<span class="number">20</span></span>):</span>    </span><br><span class="line">    sparse_features = [<span class="string">&quot;click_article_id&quot;</span>, <span class="string">&quot;user_id&quot;</span>]</span><br><span class="line">    SEQ_LEN = <span class="number">30</span> <span class="comment"># 用户点击序列的长度，短的填充，长的截断</span></span><br><span class="line">    </span><br><span class="line">    user_profile_ = data[[<span class="string">&quot;user_id&quot;</span>]].drop_duplicates(<span class="string">&#x27;user_id&#x27;</span>)</span><br><span class="line">    item_profile_ = data[[<span class="string">&quot;click_article_id&quot;</span>]].drop_duplicates(<span class="string">&#x27;click_article_id&#x27;</span>)  </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 类别编码</span></span><br><span class="line">    features = [<span class="string">&quot;click_article_id&quot;</span>, <span class="string">&quot;user_id&quot;</span>]</span><br><span class="line">    feature_max_idx = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> feature <span class="keyword">in</span> features:</span><br><span class="line">        lbe = LabelEncoder()</span><br><span class="line">        data[feature] = lbe.fit_transform(data[feature])</span><br><span class="line">        feature_max_idx[feature] = data[feature].<span class="built_in">max</span>() + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 提取user和item的画像，这里具体选择哪些特征还需要进一步的分析和考虑</span></span><br><span class="line">    user_profile = data[[<span class="string">&quot;user_id&quot;</span>]].drop_duplicates(<span class="string">&#x27;user_id&#x27;</span>)</span><br><span class="line">    item_profile = data[[<span class="string">&quot;click_article_id&quot;</span>]].drop_duplicates(<span class="string">&#x27;click_article_id&#x27;</span>)  </span><br><span class="line">    </span><br><span class="line">    user_index_2_rawid = <span class="built_in">dict</span>(<span class="built_in">zip</span>(user_profile[<span class="string">&#x27;user_id&#x27;</span>], user_profile_[<span class="string">&#x27;user_id&#x27;</span>]))</span><br><span class="line">    item_index_2_rawid = <span class="built_in">dict</span>(<span class="built_in">zip</span>(item_profile[<span class="string">&#x27;click_article_id&#x27;</span>], item_profile_[<span class="string">&#x27;click_article_id&#x27;</span>]))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 划分训练和测试集</span></span><br><span class="line">    <span class="comment"># 由于深度学习需要的数据量通常都是非常大的，所以为了保证召回的效果，往往会通过滑窗的形式扩充训练样本</span></span><br><span class="line">    train_set, test_set = gen_data_set(data, <span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 整理输入数据，具体的操作可以看上面的函数</span></span><br><span class="line">    train_model_input, train_label = gen_model_input(train_set, user_profile, SEQ_LEN)</span><br><span class="line">    test_model_input, test_label = gen_model_input(test_set, user_profile, SEQ_LEN)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 确定Embedding的维度</span></span><br><span class="line">    embedding_dim = <span class="number">16</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将数据整理成模型可以直接输入的形式</span></span><br><span class="line">    user_feature_columns = [SparseFeat(<span class="string">&#x27;user_id&#x27;</span>, feature_max_idx[<span class="string">&#x27;user_id&#x27;</span>], embedding_dim),</span><br><span class="line">                            VarLenSparseFeat(SparseFeat(<span class="string">&#x27;hist_article_id&#x27;</span>, feature_max_idx[<span class="string">&#x27;click_article_id&#x27;</span>], embedding_dim,</span><br><span class="line">                                                        embedding_name=<span class="string">&quot;click_article_id&quot;</span>), SEQ_LEN, <span class="string">&#x27;mean&#x27;</span>, <span class="string">&#x27;hist_len&#x27;</span>),]</span><br><span class="line">    item_feature_columns = [SparseFeat(<span class="string">&#x27;click_article_id&#x27;</span>, feature_max_idx[<span class="string">&#x27;click_article_id&#x27;</span>], embedding_dim)]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 模型的定义 </span></span><br><span class="line">    <span class="comment"># num_sampled: 负采样时的样本数量</span></span><br><span class="line">    model = YoutubeDNN(user_feature_columns, item_feature_columns, num_sampled=<span class="number">5</span>, user_dnn_hidden_units=(<span class="number">64</span>, embedding_dim))</span><br><span class="line">    <span class="comment"># 模型编译</span></span><br><span class="line">    model.<span class="built_in">compile</span>(optimizer=<span class="string">&quot;adam&quot;</span>, loss=sampledsoftmaxloss)  </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 模型训练，这里可以定义验证集的比例，如果设置为0的话就是全量数据直接进行训练</span></span><br><span class="line">    history = model.fit(train_model_input, train_label, batch_size=<span class="number">256</span>, epochs=<span class="number">1</span>, verbose=<span class="number">1</span>, validation_split=<span class="number">0.0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 训练完模型之后,提取训练的Embedding，包括user端和item端</span></span><br><span class="line">    test_user_model_input = test_model_input</span><br><span class="line">    all_item_model_input = &#123;<span class="string">&quot;click_article_id&quot;</span>: item_profile[<span class="string">&#x27;click_article_id&#x27;</span>].values&#125;</span><br><span class="line"></span><br><span class="line">    user_embedding_model = Model(inputs=model.user_input, outputs=model.user_embedding)</span><br><span class="line">    item_embedding_model = Model(inputs=model.item_input, outputs=model.item_embedding)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 保存当前的item_embedding 和 user_embedding 排序的时候可能能够用到，但是需要注意保存的时候需要和原始的id对应</span></span><br><span class="line">    user_embs = user_embedding_model.predict(test_user_model_input, batch_size=<span class="number">2</span> ** <span class="number">12</span>)</span><br><span class="line">    item_embs = item_embedding_model.predict(all_item_model_input, batch_size=<span class="number">2</span> ** <span class="number">12</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># embedding保存之前归一化一下</span></span><br><span class="line">    user_embs = user_embs / np.linalg.norm(user_embs, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line">    item_embs = item_embs / np.linalg.norm(item_embs, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将Embedding转换成字典的形式方便查询</span></span><br><span class="line">    raw_user_id_emb_dict = &#123;user_index_2_rawid[k]: \</span><br><span class="line">                                v <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">zip</span>(user_profile[<span class="string">&#x27;user_id&#x27;</span>], user_embs)&#125;</span><br><span class="line">    raw_item_id_emb_dict = &#123;item_index_2_rawid[k]: \</span><br><span class="line">                                v <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">zip</span>(item_profile[<span class="string">&#x27;click_article_id&#x27;</span>], item_embs)&#125;</span><br><span class="line">    <span class="comment"># 将Embedding保存到本地</span></span><br><span class="line">    pickle.dump(raw_user_id_emb_dict, <span class="built_in">open</span>(save_path + <span class="string">&#x27;user_youtube_emb.pkl&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>))</span><br><span class="line">    pickle.dump(raw_item_id_emb_dict, <span class="built_in">open</span>(save_path + <span class="string">&#x27;item_youtube_emb.pkl&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># faiss紧邻搜索，通过user_embedding 搜索与其相似性最高的topk个item</span></span><br><span class="line">    index = faiss.IndexFlatIP(embedding_dim)</span><br><span class="line">    <span class="comment"># 上面已经进行了归一化，这里可以不进行归一化了</span></span><br><span class="line"><span class="comment">#     faiss.normalize_L2(user_embs)</span></span><br><span class="line"><span class="comment">#     faiss.normalize_L2(item_embs)</span></span><br><span class="line">    index.add(item_embs) <span class="comment"># 将item向量构建索引</span></span><br><span class="line">    sim, idx = index.search(np.ascontiguousarray(user_embs), topk) <span class="comment"># 通过user去查询最相似的topk个item</span></span><br><span class="line">    </span><br><span class="line">    user_recall_items_dict = collections.defaultdict(<span class="built_in">dict</span>)</span><br><span class="line">    <span class="keyword">for</span> target_idx, sim_value_list, rele_idx_list <span class="keyword">in</span> tqdm(<span class="built_in">zip</span>(test_user_model_input[<span class="string">&#x27;user_id&#x27;</span>], sim, idx)):</span><br><span class="line">        target_raw_id = user_index_2_rawid[target_idx]</span><br><span class="line">        <span class="comment"># 从1开始是为了去掉商品本身, 所以最终获得的相似商品只有topk-1</span></span><br><span class="line">        <span class="keyword">for</span> rele_idx, sim_value <span class="keyword">in</span> <span class="built_in">zip</span>(rele_idx_list[<span class="number">1</span>:], sim_value_list[<span class="number">1</span>:]): </span><br><span class="line">            rele_raw_id = item_index_2_rawid[rele_idx]</span><br><span class="line">            user_recall_items_dict[target_raw_id][rele_raw_id] = user_recall_items_dict.get(target_raw_id, &#123;&#125;)\</span><br><span class="line">                                                                    .get(rele_raw_id, <span class="number">0</span>) + sim_value</span><br><span class="line">            </span><br><span class="line">    user_recall_items_dict = &#123;k: <span class="built_in">sorted</span>(v.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>) <span class="keyword">for</span> k, v <span class="keyword">in</span> user_recall_items_dict.items()&#125;</span><br><span class="line">    <span class="comment"># 将召回的结果进行排序</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 保存召回的结果</span></span><br><span class="line">    <span class="comment"># 这里是直接通过向量的方式得到了召回结果，相比于上面的召回方法，上面的只是得到了i2i及u2u的相似性矩阵，还需要进行协同过滤召回才能得到召回结果</span></span><br><span class="line">    <span class="comment"># 可以直接对这个召回结果进行评估，为了方便可以统一写一个评估函数对所有的召回结果进行评估</span></span><br><span class="line">    pickle.dump(user_recall_items_dict, <span class="built_in">open</span>(save_path + <span class="string">&#x27;youtube_u2i_dict.pkl&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> user_recall_items_dict</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 由于这里需要做召回评估，所以将训练集中的最后一次点击都提取了出来</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> metric_recall:</span><br><span class="line">    user_multi_recall_dict[<span class="string">&#x27;youtubednn_recall&#x27;</span>] = youtubednn_u2i_dict(all_click_df, topk=<span class="number">20</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    trn_hist_click_df, trn_last_click_df = get_hist_and_last_click(all_click_df)</span><br><span class="line">    user_multi_recall_dict[<span class="string">&#x27;youtubednn_recall&#x27;</span>] = youtubednn_u2i_dict(trn_hist_click_df, topk=<span class="number">20</span>)</span><br><span class="line">    <span class="comment"># 召回效果评估</span></span><br><span class="line">    metrics_recall(user_multi_recall_dict[<span class="string">&#x27;youtubednn_recall&#x27;</span>], trn_last_click_df, topk=<span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<pre><code>100%|██████████| 250000/250000 [00:20&lt;00:00, 12345.53it/s]


WARNING:tensorflow:From /home/yons/anaconda3/envs/tensorflow/lib/python3.6/site-packages/deepctr/layers/utils.py:171: calling reduce_sum (from tensorflow.python.ops.math_ops) with keep_dims is deprecated and will be removed in a future version.
Instructions for updating:
keep_dims is deprecated, use keepdims instead
Epoch 1/1
1149673/1149673 [==============================] - 26s 23us/step - loss: 0.1379


250000it [00:11, 22293.04it/s]</code></pre>
<h3 id="itemcf-recall">itemcf recall</h3>
<p>上面已经通过协同过滤，Embedding检索的方式得到了文章的相似度矩阵，下面使用协同过滤的思想，给用户召回与其历史文章相似的文章。 这里在召回的时候，也是用了关联规则的方式：</p>
<ul>
<li>考虑相似文章与历史点击文章顺序的权重(细节看代码)</li>
<li>考虑文章创建时间的权重，也就是考虑相似文章与历史点击文章创建时间差的权重</li>
<li>考虑文章内容相似度权重(使用Embedding计算相似文章相似度，但是这里需要注意，在Embedding的时候并没有计算所有商品两两之间的相似度，所以相似的文章与历史点击文章不存在相似度，需要做特殊处理)</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基于商品的召回i2i</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">item_based_recommend</span>(<span class="params">user_id, user_item_time_dict, i2i_sim, sim_item_topk, recall_item_num, item_topk_click, item_created_time_dict, emb_i2i_sim</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        基于文章协同过滤的召回</span></span><br><span class="line"><span class="string">        :param user_id: 用户id</span></span><br><span class="line"><span class="string">        :param user_item_time_dict: 字典, 根据点击时间获取用户的点击文章序列   &#123;user1: [(item1, time1), (item2, time2)..]...&#125;</span></span><br><span class="line"><span class="string">        :param i2i_sim: 字典，文章相似性矩阵</span></span><br><span class="line"><span class="string">        :param sim_item_topk: 整数， 选择与当前文章最相似的前k篇文章</span></span><br><span class="line"><span class="string">        :param recall_item_num: 整数， 最后的召回文章数量</span></span><br><span class="line"><span class="string">        :param item_topk_click: 列表，点击次数最多的文章列表，用户召回补全</span></span><br><span class="line"><span class="string">        :param emb_i2i_sim: 字典基于内容embedding算的文章相似矩阵</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        return: 召回的文章列表 [(item1, score1), (item2, score2)...]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 获取用户历史交互的文章</span></span><br><span class="line">    user_hist_items = user_item_time_dict[user_id]</span><br><span class="line">    user_hist_items_ = &#123;user_id <span class="keyword">for</span> user_id, _ <span class="keyword">in</span> user_hist_items&#125;</span><br><span class="line">    </span><br><span class="line">    item_rank = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> loc, (i, click_time) <span class="keyword">in</span> <span class="built_in">enumerate</span>(user_hist_items):</span><br><span class="line">        <span class="keyword">for</span> j, wij <span class="keyword">in</span> <span class="built_in">sorted</span>(i2i_sim[i].items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>)[:sim_item_topk]:</span><br><span class="line">            <span class="keyword">if</span> j <span class="keyword">in</span> user_hist_items_:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 文章创建时间差权重</span></span><br><span class="line">            created_time_weight = np.exp(<span class="number">0.8</span> ** np.<span class="built_in">abs</span>(item_created_time_dict[i] - item_created_time_dict[j]))</span><br><span class="line">            <span class="comment"># 相似文章和历史点击文章序列中历史文章所在的位置权重</span></span><br><span class="line">            loc_weight = (<span class="number">0.9</span> ** (<span class="built_in">len</span>(user_hist_items) - loc))</span><br><span class="line">            </span><br><span class="line">            content_weight = <span class="number">1.0</span></span><br><span class="line">            <span class="keyword">if</span> emb_i2i_sim.get(i, &#123;&#125;).get(j, <span class="literal">None</span>) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                content_weight += emb_i2i_sim[i][j]</span><br><span class="line">            <span class="keyword">if</span> emb_i2i_sim.get(j, &#123;&#125;).get(i, <span class="literal">None</span>) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                content_weight += emb_i2i_sim[j][i]</span><br><span class="line">                </span><br><span class="line">            item_rank.setdefault(j, <span class="number">0</span>)</span><br><span class="line">            item_rank[j] += created_time_weight * loc_weight * content_weight * wij</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 不足10个，用热门商品补全</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(item_rank) &lt; recall_item_num:</span><br><span class="line">        <span class="keyword">for</span> i, item <span class="keyword">in</span> <span class="built_in">enumerate</span>(item_topk_click):</span><br><span class="line">            <span class="keyword">if</span> item <span class="keyword">in</span> item_rank.items(): <span class="comment"># 填充的item应该不在原来的列表中</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            item_rank[item] = - i - <span class="number">100</span> <span class="comment"># 随便给个负数就行</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(item_rank) == recall_item_num:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    item_rank = <span class="built_in">sorted</span>(item_rank.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>)[:recall_item_num]</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> item_rank</span><br></pre></td></tr></table></figure>
<h3 id="itemcf-sim召回">itemcf sim召回</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先进行itemcf召回, 为了召回评估，所以提取最后一次点击</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> metric_recall:</span><br><span class="line">    trn_hist_click_df, trn_last_click_df = get_hist_and_last_click(all_click_df)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    trn_hist_click_df = all_click_df</span><br><span class="line"></span><br><span class="line">user_recall_items_dict = collections.defaultdict(<span class="built_in">dict</span>)</span><br><span class="line">user_item_time_dict = get_user_item_time(trn_hist_click_df)</span><br><span class="line"></span><br><span class="line">i2i_sim = pickle.load(<span class="built_in">open</span>(save_path + <span class="string">&#x27;itemcf_i2i_sim.pkl&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>))</span><br><span class="line">emb_i2i_sim = pickle.load(<span class="built_in">open</span>(save_path + <span class="string">&#x27;emb_i2i_sim.pkl&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>))</span><br><span class="line"></span><br><span class="line">sim_item_topk = <span class="number">20</span></span><br><span class="line">recall_item_num = <span class="number">10</span></span><br><span class="line">item_topk_click = get_item_topk_click(trn_hist_click_df, k=<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> tqdm(trn_hist_click_df[<span class="string">&#x27;user_id&#x27;</span>].unique()):</span><br><span class="line">    user_recall_items_dict[user] = item_based_recommend(user, user_item_time_dict, \</span><br><span class="line">                                                        i2i_sim, sim_item_topk, recall_item_num, \</span><br><span class="line">                                                        item_topk_click, item_created_time_dict, emb_i2i_sim)</span><br><span class="line"></span><br><span class="line">user_multi_recall_dict[<span class="string">&#x27;itemcf_sim_itemcf_recall&#x27;</span>] = user_recall_items_dict</span><br><span class="line">pickle.dump(user_multi_recall_dict[<span class="string">&#x27;itemcf_sim_itemcf_recall&#x27;</span>], <span class="built_in">open</span>(save_path + <span class="string">&#x27;itemcf_recall_dict.pkl&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> metric_recall:</span><br><span class="line">    <span class="comment"># 召回效果评估</span></span><br><span class="line">    metrics_recall(user_multi_recall_dict[<span class="string">&#x27;itemcf_sim_itemcf_recall&#x27;</span>], trn_last_click_df, topk=recall_item_num)</span><br></pre></td></tr></table></figure>
<pre><code>100%|██████████| 250000/250000 [45:08&lt;00:00, 92.31it/s] </code></pre>
<h3 id="embedding-sim-召回">embedding sim 召回</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里是为了召回评估，所以提取最后一次点击</span></span><br><span class="line"><span class="keyword">if</span> metric_recall:</span><br><span class="line">    trn_hist_click_df, trn_last_click_df = get_hist_and_last_click(all_click_df)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    trn_hist_click_df = all_click_df</span><br><span class="line"></span><br><span class="line">user_recall_items_dict = collections.defaultdict(<span class="built_in">dict</span>)</span><br><span class="line">user_item_time_dict = get_user_item_time(trn_hist_click_df)</span><br><span class="line">i2i_sim = pickle.load(<span class="built_in">open</span>(save_path + <span class="string">&#x27;emb_i2i_sim.pkl&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>))</span><br><span class="line"></span><br><span class="line">sim_item_topk = <span class="number">20</span></span><br><span class="line">recall_item_num = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">item_topk_click = get_item_topk_click(trn_hist_click_df, k=<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> tqdm(trn_hist_click_df[<span class="string">&#x27;user_id&#x27;</span>].unique()):</span><br><span class="line">    user_recall_items_dict[user] = item_based_recommend(user, user_item_time_dict, i2i_sim, sim_item_topk, </span><br><span class="line">                                                        recall_item_num, item_topk_click, item_created_time_dict, emb_i2i_sim)</span><br><span class="line">    </span><br><span class="line">user_multi_recall_dict[<span class="string">&#x27;embedding_sim_item_recall&#x27;</span>] = user_recall_items_dict</span><br><span class="line">pickle.dump(user_multi_recall_dict[<span class="string">&#x27;embedding_sim_item_recall&#x27;</span>], <span class="built_in">open</span>(save_path + <span class="string">&#x27;embedding_sim_item_recall.pkl&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> metric_recall:</span><br><span class="line">    <span class="comment"># 召回效果评估</span></span><br><span class="line">    metrics_recall(user_multi_recall_dict[<span class="string">&#x27;embedding_sim_item_recall&#x27;</span>], trn_last_click_df, topk=recall_item_num)</span><br></pre></td></tr></table></figure>
<pre><code>100%|██████████| 250000/250000 [01:00&lt;00:00, 4110.53it/s] </code></pre>
<h3 id="usercf召回">usercf召回</h3>
<p>基于用户协同过滤，核心思想是给用户推荐与其相似的用户历史点击文章，因为这里涉及到了相似用户的历史文章，这里仍然可以加上一些关联规则来给用户可能点击的文章进行加权，这里使用的关联规则主要是考虑相似用户的历史点击文章与被推荐用户历史点击商品的关系权重，而这里的关系就可以直接借鉴基于物品的协同过滤相似的做法，只不过这里是对被推荐物品关系的一个累加的过程，下面是使用的一些关系权重，及相关的代码：</p>
<ol type="1">
<li>计算被推荐用户历史点击文章与相似用户历史点击文章的相似度，文章创建时间差，相对位置的总和，作为各自的权重.</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基于用户的召回 u2u2i</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user_based_recommend</span>(<span class="params">user_id, user_item_time_dict, u2u_sim, sim_user_topk, recall_item_num, </span></span></span><br><span class="line"><span class="function"><span class="params">                         item_topk_click, item_created_time_dict, emb_i2i_sim</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        基于文章协同过滤的召回</span></span><br><span class="line"><span class="string">        :param user_id: 用户id</span></span><br><span class="line"><span class="string">        :param user_item_time_dict: 字典, 根据点击时间获取用户的点击文章序列   &#123;user1: [(item1, time1), (item2, time2)..]...&#125;</span></span><br><span class="line"><span class="string">        :param u2u_sim: 字典，文章相似性矩阵</span></span><br><span class="line"><span class="string">        :param sim_user_topk: 整数， 选择与当前用户最相似的前k个用户</span></span><br><span class="line"><span class="string">        :param recall_item_num: 整数， 最后的召回文章数量</span></span><br><span class="line"><span class="string">        :param item_topk_click: 列表，点击次数最多的文章列表，用户召回补全</span></span><br><span class="line"><span class="string">        :param item_created_time_dict: 文章创建时间列表</span></span><br><span class="line"><span class="string">        :param emb_i2i_sim: 字典基于内容embedding算的文章相似矩阵</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        return: 召回的文章列表 [(item1, score1), (item2, score2)...]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 历史交互</span></span><br><span class="line">    user_item_time_list = user_item_time_dict[user_id]    <span class="comment">#  [(item1, time1), (item2, time2)..]</span></span><br><span class="line">    user_hist_items = <span class="built_in">set</span>([i <span class="keyword">for</span> i, t <span class="keyword">in</span> user_item_time_list])   <span class="comment"># 存在一个用户与某篇文章的多次交互， 这里得去重</span></span><br><span class="line">    </span><br><span class="line">    items_rank = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> sim_u, wuv <span class="keyword">in</span> <span class="built_in">sorted</span>(u2u_sim[user_id].items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>)[:sim_user_topk]:</span><br><span class="line">        <span class="keyword">for</span> i, click_time <span class="keyword">in</span> user_item_time_dict[sim_u]:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> user_hist_items:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            items_rank.setdefault(i, <span class="number">0</span>)</span><br><span class="line">            </span><br><span class="line">            loc_weight = <span class="number">1.0</span></span><br><span class="line">            content_weight = <span class="number">1.0</span></span><br><span class="line">            created_time_weight = <span class="number">1.0</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 当前文章与该用户看的历史文章进行一个权重交互</span></span><br><span class="line">            <span class="keyword">for</span> loc, (j, click_time) <span class="keyword">in</span> <span class="built_in">enumerate</span>(user_item_time_list):</span><br><span class="line">                <span class="comment"># 点击时的相对位置权重</span></span><br><span class="line">                loc_weight += <span class="number">0.9</span> ** (<span class="built_in">len</span>(user_item_time_list) - loc)</span><br><span class="line">                <span class="comment"># 内容相似性权重</span></span><br><span class="line">                <span class="keyword">if</span> emb_i2i_sim.get(i, &#123;&#125;).get(j, <span class="literal">None</span>) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    content_weight += emb_i2i_sim[i][j]</span><br><span class="line">                <span class="keyword">if</span> emb_i2i_sim.get(j, &#123;&#125;).get(i, <span class="literal">None</span>) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    content_weight += emb_i2i_sim[j][i]</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 创建时间差权重</span></span><br><span class="line">                created_time_weight += np.exp(<span class="number">0.8</span> * np.<span class="built_in">abs</span>(item_created_time_dict[i] - item_created_time_dict[j]))</span><br><span class="line">                </span><br><span class="line">            items_rank[i] += loc_weight * content_weight * created_time_weight * wuv</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 热度补全</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(items_rank) &lt; recall_item_num:</span><br><span class="line">        <span class="keyword">for</span> i, item <span class="keyword">in</span> <span class="built_in">enumerate</span>(item_topk_click):</span><br><span class="line">            <span class="keyword">if</span> item <span class="keyword">in</span> items_rank.items(): <span class="comment"># 填充的item应该不在原来的列表中</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            items_rank[item] = - i - <span class="number">100</span> <span class="comment"># 随便给个复数就行</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(items_rank) == recall_item_num:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">    items_rank = <span class="built_in">sorted</span>(items_rank.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>)[:recall_item_num]</span><br></pre></td></tr></table></figure>
<h3 id="usercf-sim召回">usercf sim召回</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里是为了召回评估，所以提取最后一次点击</span></span><br><span class="line"><span class="comment"># 由于usercf中计算user之间的相似度的过程太费内存了，全量数据这里就没有跑，跑了一个采样之后的数据</span></span><br><span class="line"><span class="keyword">if</span> metric_recall:</span><br><span class="line">    trn_hist_click_df, trn_last_click_df = get_hist_and_last_click(all_click_df)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    trn_hist_click_df = all_click_df</span><br><span class="line">    </span><br><span class="line">user_recall_items_dict = collections.defaultdict(<span class="built_in">dict</span>)</span><br><span class="line">user_item_time_dict = get_user_item_time(trn_hist_click_df)</span><br><span class="line"></span><br><span class="line">u2u_sim = pickle.load(<span class="built_in">open</span>(save_path + <span class="string">&#x27;usercf_u2u_sim.pkl&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>))</span><br><span class="line"></span><br><span class="line">sim_user_topk = <span class="number">20</span></span><br><span class="line">recall_item_num = <span class="number">10</span></span><br><span class="line">item_topk_click = get_item_topk_click(trn_hist_click_df, k=<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> tqdm(trn_hist_click_df[<span class="string">&#x27;user_id&#x27;</span>].unique()):</span><br><span class="line">    user_recall_items_dict[user] = user_based_recommend(user, user_item_time_dict, u2u_sim, sim_user_topk, \</span><br><span class="line">                                                        recall_item_num, item_topk_click, item_created_time_dict, emb_i2i_sim)    </span><br><span class="line"></span><br><span class="line">pickle.dump(user_recall_items_dict, <span class="built_in">open</span>(save_path + <span class="string">&#x27;usercf_u2u2i_recall.pkl&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> metric_recall:</span><br><span class="line">    <span class="comment"># 召回效果评估</span></span><br><span class="line">    metrics_recall(user_recall_items_dict, trn_last_click_df, topk=recall_item_num)</span><br></pre></td></tr></table></figure>
<h2 id="user-embedding-sim召回">user embedding sim召回</h2>
<p>虽然没有直接跑usercf的计算用户之间的相似度，为了验证上述基于用户的协同过滤的代码，下面使用了YoutubeDNN过程中产生的user embedding来进行向量检索每个user最相似的topk个user，在使用这里得到的u2u的相似性矩阵，使用usercf进行召回，具体代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用Embedding的方式获取u2u的相似性矩阵</span></span><br><span class="line"><span class="comment"># topk指的是每个user, faiss搜索后返回最相似的topk个user</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">u2u_embdding_sim</span>(<span class="params">click_df, user_emb_dict, save_path, topk</span>):</span></span><br><span class="line">    </span><br><span class="line">    user_list = []</span><br><span class="line">    user_emb_list = []</span><br><span class="line">    <span class="keyword">for</span> user_id, user_emb <span class="keyword">in</span> user_emb_dict.items():</span><br><span class="line">        user_list.append(user_id)</span><br><span class="line">        user_emb_list.append(user_emb)</span><br><span class="line">        </span><br><span class="line">    user_index_2_rawid_dict = &#123;k: v <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">zip</span>(<span class="built_in">range</span>(<span class="built_in">len</span>(user_list)), user_list)&#125;    </span><br><span class="line">    </span><br><span class="line">    user_emb_np = np.array(user_emb_list, dtype=np.float32)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 建立faiss索引</span></span><br><span class="line">    user_index = faiss.IndexFlatIP(user_emb_np.shape[<span class="number">1</span>])</span><br><span class="line">    user_index.add(user_emb_np)</span><br><span class="line">    <span class="comment"># 相似度查询，给每个索引位置上的向量返回topk个item以及相似度</span></span><br><span class="line">    sim, idx = user_index.search(user_emb_np, topk) <span class="comment"># 返回的是列表</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment"># 将向量检索的结果保存成原始id的对应关系</span></span><br><span class="line">    user_sim_dict = collections.defaultdict(<span class="built_in">dict</span>)</span><br><span class="line">    <span class="keyword">for</span> target_idx, sim_value_list, rele_idx_list <span class="keyword">in</span> tqdm(<span class="built_in">zip</span>(<span class="built_in">range</span>(<span class="built_in">len</span>(user_emb_np)), sim, idx)):</span><br><span class="line">        target_raw_id = user_index_2_rawid_dict[target_idx]</span><br><span class="line">        <span class="comment"># 从1开始是为了去掉商品本身, 所以最终获得的相似商品只有topk-1</span></span><br><span class="line">        <span class="keyword">for</span> rele_idx, sim_value <span class="keyword">in</span> <span class="built_in">zip</span>(rele_idx_list[<span class="number">1</span>:], sim_value_list[<span class="number">1</span>:]): </span><br><span class="line">            rele_raw_id = user_index_2_rawid_dict[rele_idx]</span><br><span class="line">            user_sim_dict[target_raw_id][rele_raw_id] = user_sim_dict.get(target_raw_id, &#123;&#125;).get(rele_raw_id, <span class="number">0</span>) + sim_value</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 保存i2i相似度矩阵</span></span><br><span class="line">    pickle.dump(user_sim_dict, <span class="built_in">open</span>(save_path + <span class="string">&#x27;youtube_u2u_sim.pkl&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>))   </span><br><span class="line">    <span class="keyword">return</span> user_sim_dict</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取YoutubeDNN过程中产生的user embedding, 然后使用faiss计算用户之间的相似度</span></span><br><span class="line"><span class="comment"># 这里需要注意，这里得到的user embedding其实并不是很好，因为YoutubeDNN中使用的是用户点击序列来训练的user embedding,</span></span><br><span class="line"><span class="comment"># 如果序列普遍都比较短的话，其实效果并不是很好</span></span><br><span class="line">user_emb_dict = pickle.load(<span class="built_in">open</span>(save_path + <span class="string">&#x27;user_youtube_emb.pkl&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>))</span><br><span class="line">u2u_sim = u2u_embdding_sim(all_click_df, user_emb_dict, save_path, topk=<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<pre><code>250000it [00:06, 41264.31it/s]</code></pre>
<p>通过YoutubeDNN得到的user_embedding.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用召回评估函数验证当前召回方式的效果</span></span><br><span class="line"><span class="keyword">if</span> metric_recall:</span><br><span class="line">    trn_hist_click_df, trn_last_click_df = get_hist_and_last_click(all_click_df)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    trn_hist_click_df = all_click_df</span><br><span class="line"></span><br><span class="line">user_recall_items_dict = collections.defaultdict(<span class="built_in">dict</span>)</span><br><span class="line">user_item_time_dict = get_user_item_time(trn_hist_click_df)</span><br><span class="line">u2u_sim = pickle.load(<span class="built_in">open</span>(save_path + <span class="string">&#x27;youtube_u2u_sim.pkl&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>))</span><br><span class="line"></span><br><span class="line">sim_user_topk = <span class="number">20</span></span><br><span class="line">recall_item_num = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">item_topk_click = get_item_topk_click(trn_hist_click_df, k=<span class="number">50</span>)</span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> tqdm(trn_hist_click_df[<span class="string">&#x27;user_id&#x27;</span>].unique()):</span><br><span class="line">    user_recall_items_dict[user] = user_based_recommend(user, user_item_time_dict, u2u_sim, sim_user_topk, \</span><br><span class="line">                                                        recall_item_num, item_topk_click, item_created_time_dict, emb_i2i_sim)</span><br><span class="line">    </span><br><span class="line">user_multi_recall_dict[<span class="string">&#x27;youtubednn_usercf_recall&#x27;</span>] = user_recall_items_dict</span><br><span class="line">pickle.dump(user_multi_recall_dict[<span class="string">&#x27;youtubednn_usercf_recall&#x27;</span>], <span class="built_in">open</span>(save_path + <span class="string">&#x27;youtubednn_usercf_recall.pkl&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> metric_recall:</span><br><span class="line">    <span class="comment"># 召回效果评估</span></span><br><span class="line">    metrics_recall(user_multi_recall_dict[<span class="string">&#x27;youtubednn_usercf_recall&#x27;</span>], trn_last_click_df, topk=recall_item_num)</span><br></pre></td></tr></table></figure>
<pre><code>100%|██████████| 250000/250000 [04:22&lt;00:00, 950.73it/s] </code></pre>
<h2 id="冷启动问题">冷启动问题</h2>
<p>冷启动问题可以分成三类：文章冷启动，用户冷启动，系统冷启动。</p>
<ul>
<li>文章冷启动：对于一个平台系统新加入的文章，该文章没有任何的交互记录，如何推荐给用户的问题。(对于我们场景可以认为是，日志数据中没有出现过的文章都可以认为是冷启动的文章)</li>
<li>用户冷启动：对于一个平台系统新来的用户，该用户还没有文章的交互信息，如何给该用户进行推荐。(对于我们场景就是，测试集中的用户是否在测试集对应的log数据中出现过，如果没有出现过，那么可以认为该用户是冷启动用户。但是有时候并没有这么严格，我们也可以自己设定某些指标来判别哪些用户是冷启动用户，比如通过使用时长，点击率，留存率等等)</li>
<li>系统冷启动：就是对于一个平台刚上线，还没有任何的相关历史数据，此时就是系统冷启动，其实也就是前面两种的一个综合。</li>
</ul>
<p><strong>当前场景下冷启动问题的分析</strong>：</p>
<p>对当前的数据进行分析会发现，日志中所有出现过的点击文章只有3w多个，而整个文章库中却有30多万，那么测试集中的用户最后一次点击是否会点击没有出现在日志中的文章呢？如果存在这种情况，说明用户点击的文章之前没有任何的交互信息，这也就是我们所说的文章冷启动。通过数据分析还可以发现，测试集用户只有一次点击的数据占得比例还不少，其实仅仅通过用户的一次点击就给用户推荐文章使用模型的方式也是比较难的，这里其实也可以考虑用户冷启动的问题，但是这里只给出物品冷启动的一些解决方案及代码，关于用户冷启动的话提一些可行性的做法。</p>
<ol type="1">
<li>文章冷启动(没有冷启动的探索问题) 其实我们这里不是为了做文章的冷启动而做冷启动，而是猜测用户可能会点击一些没有在log数据中出现的文章，我们要做的就是如何从将近27万的文章中选择一些文章作为用户冷启动的文章，这里其实也可以看成是一种召回策略，我们这里就采用简单的比较好理解的基于规则的召回策略来获取用户可能点击的未出现在log数据中的文章。 现在的问题变成了：如何给每个用户考虑从27万个商品中获取一小部分商品？随机选一些可能是一种方案。下面给出一些参考的方案。
<ul>
<li>首先基于Embedding召回一部分与用户历史相似的文章</li>
<li>从基于Embedding召回的文章中通过一些规则过滤掉一些文章，使得留下的文章用户更可能点击。我们这里的规则，可以是，留下那些与用户历史点击文章主题相同的文章，或者字数相差不大的文章。并且留下的文章尽量是与测试集用户最后一次点击时间更接近的文章，或者是当天的文章也行。</li>
</ul></li>
<li>用户冷启动 这里对测试集中的用户点击数据进行分析会发现，测试集中有百分之20的用户只有一次点击，那么这些点击特别少的用户的召回是不是可以单独做一些策略上的补充呢？或者是在排序后直接基于规则加上一些文章呢？这些都可以去尝试，这里没有提供具体的做法。</li>
</ol>
<p><strong>注意</strong>：</p>
<p>这里看似和基于embedding计算的item之间相似度然后做itemcf是一致的，但是现在我们的目的不一样，我们这里的目的是找到相似的向量，并且还没有出现在log日志中的商品，再加上一些其他的冷启动的策略，这里需要找回的数量会偏多一点，不然被筛选完之后可能都没有文章了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先进行itemcf召回，这里不需要做召回评估，这里只是一种策略</span></span><br><span class="line">trn_hist_click_df = all_click_df</span><br><span class="line"></span><br><span class="line">user_recall_items_dict = collections.defaultdict(<span class="built_in">dict</span>)</span><br><span class="line">user_item_time_dict = get_user_item_time(trn_hist_click_df)</span><br><span class="line">i2i_sim = pickle.load(<span class="built_in">open</span>(save_path + <span class="string">&#x27;emb_i2i_sim.pkl&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>))</span><br><span class="line"></span><br><span class="line">sim_item_topk = <span class="number">150</span></span><br><span class="line">recall_item_num = <span class="number">100</span> <span class="comment"># 稍微召回多一点文章，便于后续的规则筛选</span></span><br><span class="line"></span><br><span class="line">item_topk_click = get_item_topk_click(trn_hist_click_df, k=<span class="number">50</span>)</span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> tqdm(trn_hist_click_df[<span class="string">&#x27;user_id&#x27;</span>].unique()):</span><br><span class="line">    user_recall_items_dict[user] = item_based_recommend(user, user_item_time_dict, i2i_sim, sim_item_topk, </span><br><span class="line">                                                        recall_item_num, item_topk_click,item_created_time_dict, emb_i2i_sim)</span><br><span class="line">pickle.dump(user_recall_items_dict, <span class="built_in">open</span>(save_path + <span class="string">&#x27;cold_start_items_raw_dict.pkl&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>))</span><br></pre></td></tr></table></figure>
<pre><code>100%|██████████| 250000/250000 [01:07&lt;00:00, 3690.30it/s]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基于规则进行文章过滤</span></span><br><span class="line"><span class="comment"># 保留文章主题与用户历史浏览主题相似的文章</span></span><br><span class="line"><span class="comment"># 保留文章字数与用户历史浏览文章字数相差不大的文章</span></span><br><span class="line"><span class="comment"># 保留最后一次点击当天的文章</span></span><br><span class="line"><span class="comment"># 按照相似度返回最终的结果</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_click_article_ids_set</span>(<span class="params">all_click_df</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">set</span>(all_click_df.click_article_id.values)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cold_start_items</span>(<span class="params">user_recall_items_dict, user_hist_item_typs_dict, user_hist_item_words_dict, \</span></span></span><br><span class="line"><span class="function"><span class="params">                     user_last_item_created_time_dict, item_type_dict, item_words_dict, </span></span></span><br><span class="line"><span class="function"><span class="params">                     item_created_time_dict, click_article_ids_set, recall_item_num</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        冷启动的情况下召回一些文章</span></span><br><span class="line"><span class="string">        :param user_recall_items_dict: 基于内容embedding相似性召回来的很多文章， 字典， &#123;user1: [(item1, item2), ..], &#125;</span></span><br><span class="line"><span class="string">        :param user_hist_item_typs_dict: 字典， 用户点击的文章的主题映射</span></span><br><span class="line"><span class="string">        :param user_hist_item_words_dict: 字典， 用户点击的历史文章的字数映射</span></span><br><span class="line"><span class="string">        :param user_last_item_created_time_idct: 字典，用户点击的历史文章创建时间映射</span></span><br><span class="line"><span class="string">        :param item_tpye_idct: 字典，文章主题映射</span></span><br><span class="line"><span class="string">        :param item_words_dict: 字典，文章字数映射</span></span><br><span class="line"><span class="string">        :param item_created_time_dict: 字典， 文章创建时间映射</span></span><br><span class="line"><span class="string">        :param click_article_ids_set: 集合，用户点击过得文章, 也就是日志里面出现过的文章</span></span><br><span class="line"><span class="string">        :param recall_item_num: 召回文章的数量， 这个指的是没有出现在日志里面的文章数量</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    cold_start_user_items_dict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> user, item_list <span class="keyword">in</span> tqdm(user_recall_items_dict.items()):</span><br><span class="line">        cold_start_user_items_dict.setdefault(user, [])</span><br><span class="line">        <span class="keyword">for</span> item, score <span class="keyword">in</span> item_list:</span><br><span class="line">            <span class="comment"># 获取历史文章信息</span></span><br><span class="line">            hist_item_type_set = user_hist_item_typs_dict[user]</span><br><span class="line">            hist_mean_words = user_hist_item_words_dict[user]</span><br><span class="line">            hist_last_item_created_time = user_last_item_created_time_dict[user]</span><br><span class="line">            hist_last_item_created_time = datetime.fromtimestamp(hist_last_item_created_time)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 获取当前召回文章的信息</span></span><br><span class="line">            curr_item_type = item_type_dict[item]</span><br><span class="line">            curr_item_words = item_words_dict[item]</span><br><span class="line">            curr_item_created_time = item_created_time_dict[item]</span><br><span class="line">            curr_item_created_time = datetime.fromtimestamp(curr_item_created_time)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 首先，文章不能出现在用户的历史点击中， 然后根据文章主题，文章单词数，文章创建时间进行筛选</span></span><br><span class="line">            <span class="keyword">if</span> curr_item_type <span class="keyword">not</span> <span class="keyword">in</span> hist_item_type_set <span class="keyword">or</span> \</span><br><span class="line">                item <span class="keyword">in</span> click_article_ids_set <span class="keyword">or</span> \</span><br><span class="line">                <span class="built_in">abs</span>(curr_item_words - hist_mean_words) &gt; <span class="number">200</span> <span class="keyword">or</span> \</span><br><span class="line">                <span class="built_in">abs</span>((curr_item_created_time - hist_last_item_created_time).days) &gt; <span class="number">90</span>: </span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">                </span><br><span class="line">            cold_start_user_items_dict[user].append((item, score))      <span class="comment"># &#123;user1: [(item1, score1), (item2, score2)..]...&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 需要控制一下冷启动召回的数量</span></span><br><span class="line">    cold_start_user_items_dict = &#123;k: <span class="built_in">sorted</span>(v, key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>], reverse=<span class="literal">True</span>)[:recall_item_num] \</span><br><span class="line">                                  <span class="keyword">for</span> k, v <span class="keyword">in</span> cold_start_user_items_dict.items()&#125;</span><br><span class="line">    </span><br><span class="line">    pickle.dump(cold_start_user_items_dict, <span class="built_in">open</span>(save_path + <span class="string">&#x27;cold_start_user_items_dict.pkl&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cold_start_user_items_dict</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">all_click_df_ = all_click_df.copy()</span><br><span class="line">all_click_df_ = all_click_df_.merge(item_info_df, how=<span class="string">&#x27;left&#x27;</span>, on=<span class="string">&#x27;click_article_id&#x27;</span>)</span><br><span class="line">user_hist_item_typs_dict, user_hist_item_ids_dict, user_hist_item_words_dict, user_last_item_created_time_dict = get_user_hist_item_info_dict(all_click_df_)</span><br><span class="line">click_article_ids_set = get_click_article_ids_set(all_click_df)</span><br><span class="line"><span class="comment"># 需要注意的是</span></span><br><span class="line"><span class="comment"># 这里使用了很多规则来筛选冷启动的文章，所以前面再召回的阶段就应该尽可能的多召回一些文章，否则很容易被删掉</span></span><br><span class="line">cold_start_user_items_dict = cold_start_items(user_recall_items_dict, user_hist_item_typs_dict, user_hist_item_words_dict, \</span><br><span class="line">                                              user_last_item_created_time_dict, item_type_dict, item_words_dict, \</span><br><span class="line">                                              item_created_time_dict, click_article_ids_set, recall_item_num)</span><br><span class="line"></span><br><span class="line">user_multi_recall_dict[<span class="string">&#x27;cold_start_recall&#x27;</span>] = cold_start_user_items_dict</span><br></pre></td></tr></table></figure>
<pre><code>100%|██████████| 250000/250000 [00:29&lt;00:00, 8502.04it/s] </code></pre>
<h2 id="多路召回合并">多路召回合并</h2>
<p>多路召回合并就是将前面所有的召回策略得到的用户文章列表合并起来，下面是对前面所有召回结果的汇总:</p>
<ul>
<li>基于itemcf计算的item之间的相似度sim进行的召回</li>
<li>基于embedding搜索得到的item之间的相似度进行的召回</li>
<li>YoutubeDNN召回</li>
<li>YoutubeDNN得到的user之间的相似度进行的召回</li>
<li>基于冷启动策略的召回</li>
</ul>
<p>注意： 在做召回评估的时候就会发现有些召回的效果不错有些召回的效果很差，所以对每一路召回的结果，我们可以认为的定义一些权重，来做最终的相似度融合</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combine_recall_results</span>(<span class="params">user_multi_recall_dict, weight_dict=<span class="literal">None</span>, topk=<span class="number">25</span></span>):</span></span><br><span class="line">    final_recall_items_dict = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 对每一种召回结果按照用户进行归一化，方便后面多种召回结果，相同用户的物品之间权重相加</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">norm_user_recall_items_sim</span>(<span class="params">sorted_item_list</span>):</span></span><br><span class="line">        <span class="comment"># 如果冷启动中没有文章或者只有一篇文章，直接返回，出现这种情况的原因可能是冷启动召回的文章数量太少了，</span></span><br><span class="line">        <span class="comment"># 基于规则筛选之后就没有文章了, 这里还可以做一些其他的策略性的筛选</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(sorted_item_list) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> sorted_item_list</span><br><span class="line">        </span><br><span class="line">        min_sim = sorted_item_list[-<span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">        max_sim = sorted_item_list[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        norm_sorted_item_list = []</span><br><span class="line">        <span class="keyword">for</span> item, score <span class="keyword">in</span> sorted_item_list:</span><br><span class="line">            <span class="keyword">if</span> max_sim &gt; <span class="number">0</span>:</span><br><span class="line">                norm_score = <span class="number">1.0</span> * (score - min_sim) / (max_sim - min_sim) <span class="keyword">if</span> max_sim &gt; min_sim <span class="keyword">else</span> <span class="number">1.0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                norm_score = <span class="number">0.0</span></span><br><span class="line">            norm_sorted_item_list.append((item, norm_score))</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> norm_sorted_item_list</span><br><span class="line">    </span><br><span class="line">    print(<span class="string">&#x27;多路召回合并...&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> method, user_recall_items <span class="keyword">in</span> tqdm(user_multi_recall_dict.items()):</span><br><span class="line">        print(method + <span class="string">&#x27;...&#x27;</span>)</span><br><span class="line">        <span class="comment"># 在计算最终召回结果的时候，也可以为每一种召回结果设置一个权重</span></span><br><span class="line">        <span class="keyword">if</span> weight_dict == <span class="literal">None</span>:</span><br><span class="line">            recall_method_weight = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            recall_method_weight = weight_dict[method]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> user_id, sorted_item_list <span class="keyword">in</span> user_recall_items.items(): <span class="comment"># 进行归一化</span></span><br><span class="line">            user_recall_items[user_id] = norm_user_recall_items_sim(sorted_item_list)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> user_id, sorted_item_list <span class="keyword">in</span> user_recall_items.items():</span><br><span class="line">            <span class="comment"># print(&#x27;user_id&#x27;)</span></span><br><span class="line">            final_recall_items_dict.setdefault(user_id, &#123;&#125;)</span><br><span class="line">            <span class="keyword">for</span> item, score <span class="keyword">in</span> sorted_item_list:</span><br><span class="line">                final_recall_items_dict[user_id].setdefault(item, <span class="number">0</span>)</span><br><span class="line">                final_recall_items_dict[user_id][item] += recall_method_weight * score  </span><br><span class="line">    </span><br><span class="line">    final_recall_items_dict_rank = &#123;&#125;</span><br><span class="line">    <span class="comment"># 多路召回时也可以控制最终的召回数量</span></span><br><span class="line">    <span class="keyword">for</span> user, recall_item_dict <span class="keyword">in</span> final_recall_items_dict.items():</span><br><span class="line">        final_recall_items_dict_rank[user] = <span class="built_in">sorted</span>(recall_item_dict.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>)[:topk]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将多路召回后的最终结果字典保存到本地</span></span><br><span class="line">    pickle.dump(final_recall_items_dict, <span class="built_in">open</span>(os.path.join(save_path, <span class="string">&#x27;final_recall_items_dict.pkl&#x27;</span>),<span class="string">&#x27;wb&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> final_recall_items_dict_rank</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里直接对多路召回的权重给了一个相同的值，其实可以根据前面召回的情况来调整参数的值</span></span><br><span class="line">weight_dict = &#123;<span class="string">&#x27;itemcf_sim_itemcf_recall&#x27;</span>: <span class="number">1.0</span>,</span><br><span class="line">               <span class="string">&#x27;embedding_sim_item_recall&#x27;</span>: <span class="number">1.0</span>,</span><br><span class="line">               <span class="string">&#x27;youtubednn_recall&#x27;</span>: <span class="number">1.0</span>,</span><br><span class="line">               <span class="string">&#x27;youtubednn_usercf_recall&#x27;</span>: <span class="number">1.0</span>, </span><br><span class="line">               <span class="string">&#x27;cold_start_recall&#x27;</span>: <span class="number">1.0</span>&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最终合并之后每个用户召回150个商品进行排序</span></span><br><span class="line">final_recall_items_dict_rank = combine_recall_results(user_multi_recall_dict, weight_dict, topk=<span class="number">150</span>)</span><br></pre></td></tr></table></figure>
<pre><code>  0%|          | 0/5 [00:00&lt;?, ?it/s]

多路召回合并...
itemcf_sim_itemcf_recall...
embedding_sim_item_recall...
youtubednn_recall...
youtubednn_usercf_recall...
cold_start_recall...


100%|██████████| 5/5 [00:07&lt;00:00,  1.44s/it]</code></pre>
<h2 id="总结">总结</h2>
<p>上述实现了如下召回策略： * 基于关联规则的itemcf * 基于关联规则的usercf * youtubednn召回 * 冷启动召回 &gt; 有很多地方需要优化。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">李子梅</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://lzmcosmos.github.io/2020/11/30/%E5%A4%A9%E6%B1%A0%E6%96%B0%E9%97%BB%E6%8E%A8%E8%8D%90task2/">https://lzmcosmos.github.io/2020/11/30/%E5%A4%A9%E6%B1%A0%E6%96%B0%E9%97%BB%E6%8E%A8%E8%8D%90task2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/12/01/Albert%E5%AE%9E%E6%88%98/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Albert实战</div></div></a></div><div class="next-post pull-right"><a href="/2020/11/27/%E5%A4%A9%E6%B1%A0%E6%96%B0%E9%97%BB%E6%8E%A8%E8%8D%90task1/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">天池-新闻推荐之数据分析</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div id="twikoo"></div></div></div></div></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/cosmos.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">李子梅</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">89</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">108</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">9</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/LZMcosmos"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/LZMcosmos" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:609792588@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">“莱布尼茨在他的二进位算术中看到了宇宙创始的原像。他想象1表示上帝，而0表示虚无，上帝从虚无中创造出所有实物，恰如在他的数学系统中用1和0表示了所有的数。”</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%A9%E6%B1%A0%E6%96%B0%E9%97%BB%E6%8E%A8%E8%8D%90%E4%B9%8B%E5%A4%9A%E8%B7%AF%E5%8F%AC%E5%9B%9E"><span class="toc-number">1.</span> <span class="toc-text">天池——新闻推荐之多路召回</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E5%8F%AC%E5%9B%9E"><span class="toc-number">1.1.</span> <span class="toc-text">多路召回</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AC%E5%9B%9E"><span class="toc-number">1.1.1.</span> <span class="toc-text">召回</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E5%8F%AC%E5%9B%9E-1"><span class="toc-number">1.1.2.</span> <span class="toc-text">多路召回</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E5%8C%85"><span class="toc-number">1.1.3.</span> <span class="toc-text">导入包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E4%BD%BF%E7%94%A8%E7%9A%84gpu"><span class="toc-number">1.1.4.</span> <span class="toc-text">设置使用的GPU</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-number">1.2.</span> <span class="toc-text">读取数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#minmaxscaler"><span class="toc-number">1.2.1.</span> <span class="toc-text">MinMaxScaler</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.</span> <span class="toc-text">工具函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7-%E6%96%87%E7%AB%A0-%E6%97%B6%E9%97%B4%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.1.</span> <span class="toc-text">获取用户-文章-时间函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%96%87%E7%AB%A0-%E7%94%A8%E6%88%B7-%E6%97%B6%E9%97%B4%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.2.</span> <span class="toc-text">获取文章-用户-时间函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%8E%86%E5%8F%B2%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E7%82%B9%E5%87%BB"><span class="toc-number">1.4.</span> <span class="toc-text">获取历史和最后一次点击</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%96%87%E7%AB%A0%E5%B1%9E%E6%80%A7%E7%89%B9%E5%BE%81"><span class="toc-number">1.4.1.</span> <span class="toc-text">获取文章属性特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E5%8E%86%E5%8F%B2%E7%82%B9%E5%87%BB%E7%9A%84%E6%96%87%E7%AB%A0%E4%BF%A1%E6%81%AF"><span class="toc-number">1.4.2.</span> <span class="toc-text">获取用户历史点击的文章信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%82%B9%E5%87%BB%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84topk%E4%B8%AA%E6%96%87%E7%AB%A0"><span class="toc-number">1.4.3.</span> <span class="toc-text">获取点击次数最多的topk个文章</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%A4%9A%E8%B7%AF%E5%8F%AC%E5%9B%9E%E5%AD%97%E5%85%B8"><span class="toc-number">1.4.4.</span> <span class="toc-text">定义多路召回字典</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AC%E5%9B%9E%E6%95%88%E6%9E%9C%E8%AF%84%E4%BC%B0%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.5.</span> <span class="toc-text">召回效果评估函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E7%9B%B8%E4%BC%BC%E6%80%A7%E7%9F%A9%E9%98%B5"><span class="toc-number">1.5.</span> <span class="toc-text">计算相似性矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#usercf-u2u_sim"><span class="toc-number">1.5.1.</span> <span class="toc-text">usercf u2u_sim</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item-embedding-sim"><span class="toc-number">1.5.2.</span> <span class="toc-text">item embedding sim</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#faiss%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">faiss查询的原理：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#faiss%E4%BD%BF%E7%94%A8"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">faiss使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AC%E5%9B%9E-1"><span class="toc-number">1.6.</span> <span class="toc-text">召回</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#youtubednn%E5%8F%AC%E5%9B%9E"><span class="toc-number">1.6.1.</span> <span class="toc-text">YoutubeDNN召回</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#youtubednn%E5%8F%AC%E5%9B%9E%E6%9E%B6%E6%9E%84"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">Youtubednn召回架构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#itemcf-recall"><span class="toc-number">1.6.2.</span> <span class="toc-text">itemcf recall</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#itemcf-sim%E5%8F%AC%E5%9B%9E"><span class="toc-number">1.6.3.</span> <span class="toc-text">itemcf sim召回</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#embedding-sim-%E5%8F%AC%E5%9B%9E"><span class="toc-number">1.6.4.</span> <span class="toc-text">embedding sim 召回</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#usercf%E5%8F%AC%E5%9B%9E"><span class="toc-number">1.6.5.</span> <span class="toc-text">usercf召回</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#usercf-sim%E5%8F%AC%E5%9B%9E"><span class="toc-number">1.6.6.</span> <span class="toc-text">usercf sim召回</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#user-embedding-sim%E5%8F%AC%E5%9B%9E"><span class="toc-number">1.7.</span> <span class="toc-text">user embedding sim召回</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%B7%E5%90%AF%E5%8A%A8%E9%97%AE%E9%A2%98"><span class="toc-number">1.8.</span> <span class="toc-text">冷启动问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E5%8F%AC%E5%9B%9E%E5%90%88%E5%B9%B6"><span class="toc-number">1.9.</span> <span class="toc-text">多路召回合并</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.10.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/03/13/Mysql%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" title="MySQL环境搭建与入门">MySQL环境搭建与入门</a><time datetime="2022-03-13T01:08:47.000Z" title="Created 2022-03-13 09:08:47">2022-03-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/11/01/CRF/" title="条件随机场（CRF）">条件随机场（CRF）</a><time datetime="2021-11-01T03:28:44.000Z" title="Created 2021-11-01 11:28:44">2021-11-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/07/14/%E5%AD%97%E7%AC%A6%E4%B8%B2/" title="字符串">字符串</a><time datetime="2021-07-13T16:30:25.000Z" title="Created 2021-07-14 00:30:25">2021-07-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/06/29/Heap/" title="堆">堆</a><time datetime="2021-06-29T04:45:04.000Z" title="Created 2021-06-29 12:45:04">2021-06-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/05/14/Stacking-of-Steam/" title="Stacking集成学习案例二：蒸汽量预测">Stacking集成学习案例二：蒸汽量预测</a><time datetime="2021-05-14T03:50:07.000Z" title="Created 2021-05-14 11:50:07">2021-05-14</time></div></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/Nebula_planets-Universe.jpg)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 李子梅</div><div class="footer_custom_text">welcome to my <a href="https://lzmcosmos.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        addClass: [200,() => {
          document.querySelectorAll('mjx-container:not([display=\'true\']').forEach( node => {
            const target = node.parentNode
            if (!target.classList.contains('has-jax')) {
              target.classList.add('mathjax-overflow')
            }
          })
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>function loadTwikoo () {
  function init () {
    twikoo.init({ 
      envId: 'lzm-blog-8gx8fhrs09a28b34' 
    })
  }

  if (typeof twikoo.init === 'function') {
    init()
  } else {
    $.getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js', init)
  }
}

if ('Twikoo' === 'Twikoo' || !false) {
  if (false) btf.loadComment(document.getElementById('twikoo'), loadTwikoo)
  else loadTwikoo()
} else {
  function loadOtherComment () {
    loadTwikoo()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script>(function(){
  const bp = document.createElement('script');
  const curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https'){
  bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  bp.dataset.pjax = ''
  const s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})()</script></div></body></html>