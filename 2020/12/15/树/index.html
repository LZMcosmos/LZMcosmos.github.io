<!DOCTYPE html><html lang="zn-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>树 | LZMcosmos</title><meta name="keywords" content="树,二叉树,DFS与BFS"><meta name="author" content="李子梅"><meta name="copyright" content="李子梅"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="树 树的定义有两点：  有且仅有一个特定的称为根（root）的结点； 当结点数量&gt;1时，其余结点可分为若干个互不相交的有限集，其中每个集合也可以看作一颗树，称之为根的子树。   树的结点 结点：使用树结构存储的每一个数据元素都被称为“结点”。例如，上图（A）中，数据元素 A 就是一个结点； 父结点（双亲结点）、子结点和兄弟结点：对于上图（A）中的结点 A、B、C、D 来说，A">
<meta property="og:type" content="article">
<meta property="og:title" content="树">
<meta property="og:url" content="https://lzmcosmos.github.io/2020/12/15/%E6%A0%91/index.html">
<meta property="og:site_name" content="LZMcosmos">
<meta property="og:description" content="树 树的定义有两点：  有且仅有一个特定的称为根（root）的结点； 当结点数量&gt;1时，其余结点可分为若干个互不相交的有限集，其中每个集合也可以看作一颗树，称之为根的子树。   树的结点 结点：使用树结构存储的每一个数据元素都被称为“结点”。例如，上图（A）中，数据元素 A 就是一个结点； 父结点（双亲结点）、子结点和兄弟结点：对于上图（A）中的结点 A、B、C、D 来说，A">
<meta property="og:locale" content="zn_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2020-12-15T11:43:25.000Z">
<meta property="article:modified_time" content="2021-06-25T10:48:20.472Z">
<meta property="article:author" content="李子梅">
<meta property="article:tag" content="树">
<meta property="article:tag" content="二叉树">
<meta property="article:tag" content="DFS与BFS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/cosmos.jpg"><link rel="canonical" href="https://lzmcosmos.github.io/2020/12/15/%E6%A0%91/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-06-25 18:48:20'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/cosmos.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">90</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">109</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">9</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/Nebula_planets-Universe.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">LZMcosmos</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">树</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2020-12-15T11:43:25.000Z" title="Created 2020-12-15 19:43:25">2020-12-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-06-25T10:48:20.472Z" title="Updated 2021-06-25 18:48:20">2021-06-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="树">树</h2>
<p>树的定义有两点：</p>
<ol type="1">
<li>有且仅有一个特定的称为根（root）的结点；</li>
<li>当结点数量&gt;1时，其余结点可分为若干个互不相交的有限集，其中每个集合也可以看作一颗树，称之为根的子树。 <img src="/img/tree.png" /></li>
</ol>
<h3 id="树的结点">树的结点</h3>
<p><strong>结点</strong>：使用树结构存储的每一个数据元素都被称为“结点”。例如，上图（A）中，数据元素 A 就是一个结点；</p>
<p><strong>父结点（双亲结点）、子结点和兄弟结点：</strong>对于上图（A）中的结点 A、B、C、D 来说，A 是 B、C、D 结点的父结点（也称为“双亲结点”），而 B、C、D 都是 A 结点的子结点（也称“孩子结点”）。对于 B、C、D 来说，它们都有相同的父结点，所以它们互为兄弟结点。</p>
<p><strong>堂兄弟</strong>:如果两个结点的父结点虽不相同，但是它们的父结点处在同一层次上，那么这两个结点互为堂兄弟。例如，上面图（A）中，结点 G 和 E、F、H、I、J的父结点都在第二层，所以之间为堂兄弟的关系。</p>
<p><strong>树根结点</strong>（简称“根结点”）：每一个非空树都有且只有一个被称为根的结点。上面图（A）中，结点 A 就是整棵树的根结点。 &gt; 树根的判断依据为：如果一个结点没有父结点，那么这个结点就是整棵树的根结点。</p>
<p><strong>叶子结点</strong>：如果结点没有任何子结点，那么此结点称为叶子结点（叶结点）。例如上面图（A）中，结点 K、L、F、G、M、I、J 都是这棵树的叶子结点。</p>
<h3 id="子树和空树">子树和空树</h3>
<p><strong>子树</strong>：如上面图（A）中，整棵树的根结点为结点 A，而如果单看结点 B、E、F、K、L 组成的部分来说，也是棵树，而且节点 B 为这棵树的根结点。所以称 B、E、F、K、L 这几个结点组成的树为整棵树的子树；同样，结点 E、K、L 构成的也是一棵子树，根结点为 E。 &gt; 注意：单个结点也是一棵树，只不过根结点就是它本身。上面图（A）中，结点 K、L、F 等都是树，且都是整棵树的子树。</p>
<p><strong>空树</strong>：如果集合本身为空，那么构成的树就被称为空树。空树中没有结点。</p>
<p><strong>补充</strong>：在树结构中，对于具有同一个根结点的各个子树，相互之间不能有交集。例如，上面图（A）中，除了根结点 A，其余元素又各自构成了三个子树，根结点分别为 B、C、D，这三个子树相互之间没有相同的结点。如果有，就破坏了树的结构，不能算做是一棵树。</p>
<h3 id="结点的度和层次">结点的度和层次</h3>
<ol type="1">
<li>对于一个结点，拥有的子树数（结点有多少分支）称为结点的度（Degree）。例如，上面图（A）中，根结点 A 下分出了 3 个子树，所以，结点 A 的度为 3。一棵树的度是树内各结点的度的最大值。上面图（A）表示的树中，各个结点的度的最大值为3，所以，整棵树的度的值是 3。</li>
<li>结点的层次：从一棵树的树根开始，<strong>树根所在层为第一层</strong>，根的孩子结点所在的层为第二层，依次类推。对于上面图（A）来说，A 结点在第一层，B、C、D 为第二层，E、F、G、H、I、J 在第三层，K、L、M 在第四层。</li>
</ol>
<p><strong>一棵树的深度（高度）</strong>是树中结点所在的<strong>最大</strong>的层次。图 1（A）树的深度为 4。</p>
<h3 id="有序树和无序树">有序树和无序树</h3>
<p>如果树中结点的子树从左到右看,<strong>左边和右边有顺序</strong>，这棵树称为<strong>有序树</strong>；反之称为<strong>无序树</strong>。</p>
<p>在有序树中，一个结点最左边的子树称为"第一个孩子"，最右边的称为"最后一个孩子"。 拿上面图（A）来说，如果是其本身是一棵有序树，则以结点 B 为根结点的子树为整棵树的第一个孩子，以结点 D 为根结点的子树为整棵树的最后一个孩子。</p>
<h3 id="森林">森林</h3>
<p>由 m（m &gt;= 0）个<strong>互不相交的树</strong>组成的集合被称为<strong>森林</strong>。</p>
<p>树可以理解为是由根结点和若干子树构成的，而这若干子树本身是一个森林，所以，树还可以理解为是由根结点和森林组成的。用一个式子表示为： Tree =（root,F） 其中，root 表示树的根结点，F 表示由 m（m &gt;= 0）棵树组成的森林。</p>
<blockquote>
<p>参考链接：https://zhuanlan.zhihu.com/p/60222380 http://c.biancheng.net/view/3383.html 选取了其中的内容，并做了部分修改。</p>
</blockquote>
<h2 id="二叉树">二叉树</h2>
<h3 id="二叉树定义">二叉树定义</h3>
<p>满足以下两个条件的树就是二叉树：</p>
<ol type="1">
<li>本身是有序树；</li>
<li>树中包含的各个节点的度不能超过 2，即只能是 0、1 或者 2； <img src="/img/binarytree.gif" /></li>
</ol>
<h3 id="二叉树的性质">二叉树的性质</h3>
<p>二叉树具有以下几个性质：</p>
<ol type="1">
<li>二叉树中，第 i 层最多有 <span class="math inline">\(2^{i-1}\)</span> 个结点。</li>
<li>如果二叉树的深度为 K，那么此二叉树最多有 <span class="math inline">\(2^{2K-1}\)</span> 个结点。</li>
<li>二叉树中，终端结点数（叶子结点数）为 n0，度为 2 的结点数为 n2，则 n0=n2+1。</li>
</ol>
<blockquote>
<p>性质3的计算方法为：对于一个二叉树来说，除了度为0的叶子结点和度为2的结点，剩下的就是度为 1 的结点（设为n1），那么总结点n=n0+n1+n2。同时，对于每一个结点来说都是由其父结点分支表示的，假设树中分枝数为 B，那么总结点数 n=B+1。而分枝数是可以通过 n1 和 n2 表示的，即 B=n1+2*n2。所以，n 用另外一种方式表示为 n=n1+2*n2+1。 两种方式得到的 n 值组成一个方程组，就可以得出 n0=n2+1。</p>
</blockquote>
<h3 id="满二叉树和完全二叉树">满二叉树和完全二叉树</h3>
<ul>
<li><strong>满二叉树</strong></li>
</ul>
<p>如果二叉树中除了叶子结点，每个结点的度都为 2，则此二叉树称为满二叉树。</p>
<p><img src="/img/fullBinaryTree.gif" /></p>
<p>满二叉树除了满足普通二叉树的性质，还具有以下性质：</p>
<ol type="1">
<li>满二叉树中第 i 层的节点数为 <span class="math inline">\(2^{i-1}\)</span> 个。</li>
<li>深度为 k 的满二叉树必有 <span class="math inline">\(2^{k}-1\)</span> 个节点 ，叶子数为 <span class="math inline">\(2^{k-1}\)</span>。</li>
<li>满二叉树中不存在度为1的节点，每一个分支点中都两棵深度相同的子树，且叶子节点都在最底层。</li>
<li>具有 n 个节点的满二叉树的深度为 <span class="math inline">\(log_{2}(n+1)\)</span>。</li>
</ol>
<ul>
<li><strong>完全二叉树</strong></li>
</ul>
<p>如果二叉树中除了最后一层节点外满足为满二叉树，最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树。 <img src="/img/completeBinaryTree.gif" /></p>
<p>性质：</p>
<ol type="1">
<li>n个结点的完全二叉树的深度为 <span class="math inline">\(⌊log_{2}n⌋+1\)</span>。</li>
<li>如果将含有的结点按照层次从左到右依次标号（上面图a)），对于任意一个结点 i ，完全二叉树成立：<strong>当 i&gt;1 时</strong>，父亲结点为结点[i/2]（i=1时，表示的是根结点，无父亲结点)。<strong>如果 2*i&gt;n(总结点的个数)</strong>,则结点i肯定没有左孩子（为叶子结点）；否则其左孩子是结点 2*i 。<strong>如果 2*i+1&gt;n</strong> ，则结点 i 肯定没有右孩子；否则右孩子是结点 2*i+1 。</li>
</ol>
<blockquote>
<p><span class="math inline">\(⌊log_{2}n⌋\)</span> 表示取小于 <span class="math inline">\(log_{2}n\)</span> 的最大整数。例如，<span class="math inline">\(⌊log_{2}4⌋ = 2\)</span>，而 <span class="math inline">\(⌊log_{2}5⌋\)</span> 结果也是 2。</p>
</blockquote>
<blockquote>
<p>参考链接：http://c.biancheng.net/data_structure/tree/ 部分小问题修改。</p>
</blockquote>
<h3 id="二叉树的生成">二叉树的生成</h3>
<h4 id="创建二叉树结点">创建二叉树结点</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="literal">None</span></span>):</span></span><br><span class="line">		self.val = val</span><br><span class="line">		self.left = <span class="literal">None</span></span><br><span class="line">		self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h4 id="创建一颗二叉树">创建一颗二叉树</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root = Node(<span class="string">&quot;apple&quot;</span>)</span><br><span class="line">Node1 = Node(<span class="string">&quot;banana&quot;</span>)</span><br><span class="line">Node2 = Node(<span class="string">&quot;cherry&quot;</span>)</span><br><span class="line">Node3= Node(<span class="string">&quot;dates&quot;</span>)</span><br><span class="line"></span><br><span class="line">root.left = Node1</span><br><span class="line">root.right = Node2</span><br><span class="line">Node1.left = Node3</span><br></pre></td></tr></table></figure>
<p>上述创建的二叉树为： <img src="/img/tree_01.png" /></p>
<h3 id="二叉树的遍历">二叉树的遍历</h3>
<h4 id="深度优先搜索">深度优先搜索</h4>
<p>深度优先搜索是指当前结点有子节点的话就<strong>向下搜索</strong>。深度优先搜索分为<strong>前序、中序和后序遍历</strong>三种遍历方式。 <img src="/img/traversal.png" /></p>
<h5 id="前序遍历">前序遍历</h5>
<ul>
<li><strong>递归</strong>实现</li>
</ul>
<p><strong>方法</strong>：先访问根节点，然后递归先序遍历左子树和右子树。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">root</span>):</span></span><br><span class="line">	preorder = []</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">traversal</span>(<span class="params">root</span>):</span></span><br><span class="line">		<span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="comment">## 访问根节点</span></span><br><span class="line">		preorder.append(root.val)</span><br><span class="line">		<span class="comment">## 先序遍历左子树</span></span><br><span class="line">		preorderTraversal(root.left)</span><br><span class="line">		<span class="comment">## 先序遍历右子树</span></span><br><span class="line">		preorderTraversal(root.right)</span><br><span class="line"></span><br><span class="line">	traversal(root)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> preorder</span><br></pre></td></tr></table></figure> * <strong>迭代</strong>实现</p>
<p><strong>方法</strong>：借助一个<strong>栈</strong>存放节点的<strong>右子树</strong>。如果节点不空或者栈不空进行循环，每次循环首先将<strong>当前节点</strong>（一开始是根节点 ）加入到遍历序列中去，如果节点<strong>存在右子树</strong>则将其右子树<strong>入栈</strong>，<strong>左孩子不为空</strong>时令<strong>当前节点为左孩子</strong>否则<strong>从栈顶出栈节点(右孩子)</strong>。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">root</span>):</span></span><br><span class="line">	node = root</span><br><span class="line">	stack = []</span><br><span class="line">	preorder = []</span><br><span class="line">	<span class="keyword">while</span> node != <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">if</span> node != <span class="literal">None</span>:</span><br><span class="line">			preorder.append(node.val) <span class="comment">## 访问节点</span></span><br><span class="line">			<span class="keyword">if</span> node.right != <span class="literal">None</span>:</span><br><span class="line">				stack.append(node.right)</span><br><span class="line">			node = node.left</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			node = stack.pop()</span><br><span class="line">	<span class="keyword">return</span> preorder</span><br></pre></td></tr></table></figure> &gt; 前序遍历上面图中的二叉树的顺序为：8 7 5 20 9 13 14</p>
<h5 id="中序遍历">中序遍历</h5>
<ul>
<li><strong>递归</strong>实现</li>
</ul>
<p><strong>方法</strong>：递归中序遍历左子树，访问根节点，递归中序遍历右子树 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">root</span>):</span></span><br><span class="line">	inoder = []</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">traversal</span>(<span class="params">root</span>):</span></span><br><span class="line">		<span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="comment">## 中序遍历左子树</span></span><br><span class="line">		traversal(root.left)</span><br><span class="line">		<span class="comment">## 访问根节点</span></span><br><span class="line">		inoder.append(root.val)</span><br><span class="line">		<span class="comment">## 中序遍历右子树</span></span><br><span class="line">		traversal(root.right)</span><br><span class="line">	</span><br><span class="line">	traversal(root)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> inoder</span><br></pre></td></tr></table></figure> * <strong>迭代</strong>实现</p>
<p><strong>方法</strong>：借助一个栈，将当前非空节点（最开始是根节点）入栈，如果节点存在左子树，则将左子树节点入栈，继续循环判断左子树是否存在左孩子，入栈，直到不存在左孩子的节点，将当前节点从栈中弹出，并加入到遍历序列中，并将当前节点的右孩子入栈。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inoderTraversal</span>(<span class="params">root</span>):</span></span><br><span class="line">	node = root</span><br><span class="line">	inoder = []</span><br><span class="line">	stack = []</span><br><span class="line">	<span class="keyword">while</span> node != <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">if</span> node != <span class="literal">None</span>:</span><br><span class="line">			stack.append(node)</span><br><span class="line">			node = node.left</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			node = stack.pop()</span><br><span class="line">			inoder.append(node.val)</span><br><span class="line">			node = node.right</span><br><span class="line">	<span class="keyword">return</span> inoder</span><br></pre></td></tr></table></figure> &gt; 中序遍历上面图中的二叉树的顺序为：5 7 20 8 13 9 14</p>
<h5 id="后续遍历">后续遍历</h5>
<ul>
<li><strong>递归</strong>实现</li>
</ul>
<p><strong>方法</strong>：递归后序遍历左子树，递归后序遍历右子树，访问根节点 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">root</span>):</span></span><br><span class="line">	postorder = []</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">traversal</span>(<span class="params">root</span>):</span></span><br><span class="line">		<span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		traversal(root.left)</span><br><span class="line">		traversal(root.right)</span><br><span class="line">		postorder.append(root.val)</span><br><span class="line"></span><br><span class="line">	traversal(root)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> postorder</span><br></pre></td></tr></table></figure> * <strong>迭代</strong>实现</p>
<p><strong>方法</strong>： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postoderTraversal</span>(<span class="params">root</span>):</span></span><br><span class="line">	node = root</span><br><span class="line">	postorder = []</span><br><span class="line">	stack = []</span><br><span class="line">	pre = []</span><br><span class="line">	<span class="keyword">while</span> node != <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">if</span> node != <span class="literal">None</span>:</span><br><span class="line">			stack.append(node)</span><br><span class="line">			node = node.left</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			node = stack.pop()</span><br><span class="line">			<span class="keyword">if</span> node.right == <span class="literal">None</span> <span class="keyword">or</span> node.right == pre:</span><br><span class="line">				postorder.append(node.val)</span><br><span class="line">				pre = node</span><br><span class="line">				node = <span class="literal">None</span></span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				stack.append(node)</span><br><span class="line">				node = node.right</span><br><span class="line">	<span class="keyword">return</span> postorder</span><br></pre></td></tr></table></figure> &gt; 后序遍历上面图中的二叉树的顺序为：5 20 7 13 14 9 8</p>
<h4 id="广度优先搜索">广度优先搜索</h4>
<p>广度优先搜索又叫层次遍历，它从访问根节点出发，依次从左到右访问下一层结点以及下下层结点...直到最后一层。 <img src="/img/tree_01.png" /> 上图的层次遍历结果为：[['apple'], ['banana', 'cherry'], ['dates']]</p>
<p><strong>广度优先搜索(层次遍历)的实现</strong>： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span>(<span class="params">root</span>):</span></span><br><span class="line">	<span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">		<span class="keyword">return</span> []</span><br><span class="line">	queue = []</span><br><span class="line">	order = []</span><br><span class="line">	queue.append(root)</span><br><span class="line">	<span class="keyword">while</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span>:</span><br><span class="line">		level_node_num = <span class="built_in">len</span>(queue)</span><br><span class="line">		level = []</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(level_node_num):</span><br><span class="line">			node = queue.pop(<span class="number">0</span>)</span><br><span class="line">			level.append(node.val)</span><br><span class="line">			<span class="keyword">if</span> node.left != <span class="literal">None</span>:</span><br><span class="line">				queue.append(node.left)</span><br><span class="line">			<span class="keyword">if</span> node.right != <span class="literal">None</span>:</span><br><span class="line">				queue.append(node.right)</span><br><span class="line">		order.append(level)</span><br><span class="line">	<span class="keyword">return</span> order</span><br></pre></td></tr></table></figure> ### 二叉树的重要性</p>
<blockquote>
<p>这个part参考： https://labuladong.github.io/algo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B3%BB%E5%88%971.html</p>
</blockquote>
<p>举个例子，比如说经典算法「快速排序」和「归并排序」，对于这两个算法，你有什么理解？如果你说，快速排序就是个二叉树的前序遍历，归并排序就是个二叉树的后续遍历，那么你是个算法高手了。</p>
<p>为什么快速排序和归并排序能和二叉树扯上关系？简单分析一下它们的算法思想和代码框架：</p>
<p><strong>快速排序</strong>的逻辑是，若要对 nums[low..high] 进行排序，我们先找一个<strong>分界点 p</strong>，通过<strong>交换元素</strong>使得(左边都小右边都大) nums[low..p-1] 都小于等于 nums[p]，且 nums[p+1..high] 都大于 nums[p]，然后递归地去 nums[low..p-1] 和 nums[p+1..high] 中寻找新的分界点，最后整个数组就被排序了。</p>
<p>快速排序的代码如下(完整代码)：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##划分函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">arr, low, high</span>):</span></span><br><span class="line">	mid_value = arr[low] <span class="comment">## 以数组中第一个进行划分</span></span><br><span class="line">	<span class="keyword">while</span> low != high:</span><br><span class="line">		<span class="keyword">while</span> arr[high] &gt; mid_value:</span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">arr, low, high</span>):</span></span><br><span class="line">    mid_value = arr[low] <span class="comment">## 以数组中第一个进行划分</span></span><br><span class="line">    flag = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">while</span> low &lt; high:</span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            flag = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">while</span> arr[high] &gt; mid_value:</span><br><span class="line">                <span class="keyword">if</span> high &gt; low:</span><br><span class="line">                    high -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            arr[low] = arr[high]</span><br><span class="line">            <span class="keyword">if</span> high &gt; low:</span><br><span class="line">                low += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            flag = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">while</span> arr[low] &lt; mid_value:</span><br><span class="line">                <span class="keyword">if</span> low &lt; high:</span><br><span class="line">                    low += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            arr[high] = arr[low]</span><br><span class="line">            <span class="keyword">if</span> high &gt; low:</span><br><span class="line">                high -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    arr[low] = mid_value <span class="comment">## high和low一样</span></span><br><span class="line">    <span class="keyword">return</span> low</span><br><span class="line"></span><br><span class="line"><span class="comment">## 快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">arr, low, high</span>):</span></span><br><span class="line">    <span class="keyword">if</span> low &gt;= high:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment">## 前序遍历</span></span><br><span class="line">    p = partition(arr, low, high)</span><br><span class="line">    </span><br><span class="line">    quick_sort(arr, low, p-<span class="number">1</span>)</span><br><span class="line">    quick_sort(arr, p+<span class="number">1</span>, high)</span><br></pre></td></tr></table></figure>
<p><strong>归并排序</strong>的逻辑，若要对 nums[low..high] 进行排序，我们<strong>先对 nums[low..mid] 排序</strong>，再<strong>对 nums[mid+1..high] 排序</strong>，最后把这<strong>两个有序的子数组合并</strong>，整个数组就排好序了。</p>
<p>归并排序的代码框架如下(不完整代码)： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span>(<span class="params">arr, low, high</span>):</span></span><br><span class="line">	<span class="comment">## 后序遍历的框架</span></span><br><span class="line">	mid = (low+high) // <span class="number">2</span></span><br><span class="line">	left = merge_sort(arr, low, mid)</span><br><span class="line">	right = merger_sort(arr, mid+<span class="number">1</span>, high)</span><br><span class="line"></span><br><span class="line">	result = merge(left, right)</span><br><span class="line">	<span class="keyword">return</span> result</span><br></pre></td></tr></table></figure> 上述归并排序就是先对左右子数组排序，然后合并。另外，这也就是分治算法的思想。</p>
<h3 id="二叉树编程题">二叉树编程题</h3>
<blockquote>
<p>大部分来自leetcode</p>
</blockquote>
<h4 id="翻转二叉树">翻转二叉树</h4>
<p><strong>问题描述</strong>：翻转一棵二叉树。</p>
<p><strong>示例</strong>：</p>
<p><strong>python实现</strong>： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span>(<span class="params">self, root: TreeNode</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        tmp = root.left</span><br><span class="line">        root.left = root.right</span><br><span class="line">        root.right = tmp</span><br><span class="line">        self.invertTree(root.left)</span><br><span class="line">        self.invertTree(root.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure> #### 二叉树的锯齿形层序遍历</p>
<p><strong>问题陈述</strong>：给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
<p>例如： 给定二叉树<code>[3,9,20,null,null,15,7]</code>,</p>
<p>3 /<br />
9 20 /<br />
15 7</p>
<p>返回锯齿形层序遍历如下：</p>
<p>[ [3], [20,9], [15,7]]</p>
<p><strong>python层次遍历</strong>实现该题：</p>
<p>层次遍历稍微修改下即可。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">zigzagLevelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        queue = []</span><br><span class="line">        queue.append(root)</span><br><span class="line">        flag = <span class="number">1</span> <span class="comment">## 奇数从左往右</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span>:</span><br><span class="line">            length = <span class="built_in">len</span>(queue)</span><br><span class="line">            level = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">                node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> flag % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                    level.append(node.val)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    level.insert(<span class="number">0</span>, node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">            result.append(level)</span><br><span class="line">            flag += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure> #### 填充每个节点的下一个右侧指针</p>
<p><strong>问题陈述</strong>：给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
<p>struct Node { int val; Node *left; Node *right; Node *next; }</p>
<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>
<p>初始状态下，所有 next 指针都被设置为 NULL。</p>
<p><strong>进阶</strong>：</p>
<p>你只能使用常量级额外空间。 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</p>
<p><strong>示例</strong>：</p>
<p><img src="/img/116_sample.png" /></p>
<pre><code>输入：root = [1,2,3,4,5,6,7]
输出：[1,#,2,3,#,4,5,6,7,#]
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，&#39;#&#39; 标志着每一层的结束。</code></pre>
<p><strong>python层次遍历</strong>实现该题：</p>
<blockquote>
<p>用到了队列，而队列是跟输入规模相关的，所以不是常量空间</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; &#x27;Node&#x27;:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        queue = []</span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span>:</span><br><span class="line">            length = <span class="built_in">len</span>(queue)</span><br><span class="line">            node = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                    node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">if</span> node.left: queue.append(node.left)</span><br><span class="line">                    <span class="keyword">if</span> node.right: queue.append(node.right)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    tmp = queue.pop(<span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">if</span> tmp.left:</span><br><span class="line">                        queue.append(tmp.left)</span><br><span class="line">                    <span class="keyword">if</span> tmp.right:</span><br><span class="line">                        queue.append(tmp.right)</span><br><span class="line">                    node.<span class="built_in">next</span> = tmp</span><br><span class="line">                    node = tmp</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p><strong>python递归</strong>实现： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; &#x27;Node&#x27;:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            root.left.<span class="built_in">next</span> = root.right</span><br><span class="line">            <span class="keyword">if</span> root.<span class="built_in">next</span>:</span><br><span class="line">                root.right.<span class="built_in">next</span> = root.<span class="built_in">next</span>.left</span><br><span class="line">        self.connect(root.left)</span><br><span class="line">        self.connect(root.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure> #### 二叉树展开为链表</p>
<p><strong>问题陈述</strong>：给定一个二叉树，原地(in place与空间复杂度O(1)不同)将它展开为一个单链表。</p>
<p>例如，给定二叉树 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   5</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">3   4   6</span><br></pre></td></tr></table></figure> 将其展开为：</p>
<p>1   2  <br />
3   4  <br />
5   6</p>
<p><strong>python递归</strong>实现： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatten</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">        node_left_flatten = self.flatten(root.left)</span><br><span class="line">        node_right_flatten = self.flatten(root.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> node_left_flatten:</span><br><span class="line">            node = node_left_flatten</span><br><span class="line">            <span class="keyword">while</span> node.right:</span><br><span class="line">                node = node.right</span><br><span class="line">            node.right = node_right_flatten </span><br><span class="line">            root.right = node_left_flatten</span><br><span class="line">        root.left = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure> #### 二叉树的最近公共祖先</p>
<p><strong>问题陈述</strong>：给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4] <img src="/img/BTreeNearestParent.png" /></p>
<p><strong>示例 1</strong>: 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 输出: 3 解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</p>
<p><strong>示例 2</strong>: 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 输出: 5 解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。  </p>
<p><strong>说明</strong>: · 所有节点的值都是唯一的。 · p、q 为不同节点且均存在于给定的二叉树中。</p>
<p><strong>python递归实现</strong>： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; &#x27;TreeNode&#x27;:</span></span><br><span class="line">        node = root</span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> node == p <span class="keyword">or</span> node == q:</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        left = self.lowestCommonAncestor(node.left, p, q)</span><br><span class="line">        right = self.lowestCommonAncestor(node.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        <span class="keyword">elif</span> left:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">elif</span> right:</span><br><span class="line">            <span class="keyword">return</span> right                </span><br></pre></td></tr></table></figure> #### 最大二叉树</p>
<p><strong>问题陈述</strong>：给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：</p>
<ul>
<li>二叉树的根是数组中的最大元素。</li>
<li>左子树是通过数组中最大值左边部分构造出的最大二叉树。</li>
<li>右子树是通过数组中最大值右边部分构造出的最大二叉树。</li>
<li>通过给定的数组构建最大二叉树，并且输出这个树的根节点。</li>
</ul>
<p><strong>示例</strong> ：</p>
<p>输入：[3,2,1,6,0,5] 输出：返回下面这棵树的根节点：</p>
<p>6 /  <br />
3 5   / 2 0<br />
  1  </p>
<p><strong>提示</strong>：给定的数组的大小在 [1, 1000] 之间。</p>
<p><strong>python递归</strong>实现： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">constructMaximumBinaryTree</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        root = TreeNode(<span class="built_in">max</span>(nums))</span><br><span class="line">        max_num_index = nums.index(<span class="built_in">max</span>(nums)) </span><br><span class="line">        root.left = self.constructMaximumBinaryTree(nums[:max_num_index])</span><br><span class="line">        root.right = self.constructMaximumBinaryTree(nums[max_num_index+<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure> #### 从前序与中序遍历序列构造二叉树</p>
<p><strong>问题陈述</strong>：根据一棵树的前序遍历与中序遍历构造二叉树。</p>
<p><strong>注意</strong>: 你可以假设树中没有重复的元素。</p>
<p>例如，给出: 前序遍历 preorder = [3,9,20,15,7] 中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树：</p>
<p>3 /<br />
9 20 /<br />
15 7</p>
<p><strong>python递归</strong>实现： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, preorder: List[<span class="built_in">int</span>], inorder: List[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(preorder) == <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(inorder) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(preorder) == <span class="number">1</span> <span class="keyword">or</span> <span class="built_in">len</span>(inorder) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(preorder[<span class="number">0</span>])        </span><br><span class="line">        root = TreeNode(preorder[<span class="number">0</span>])</span><br><span class="line">        root_index = inorder.index(preorder[<span class="number">0</span>])</span><br><span class="line">        <span class="comment">## 判断左右子树有为空的情况</span></span><br><span class="line">        <span class="keyword">if</span> root_index != <span class="number">0</span>:</span><br><span class="line">            root.left = self.buildTree(preorder[<span class="number">1</span>:root_index+<span class="number">1</span>], inorder[:root_index]) </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            root.left = self.buildTree([], [])</span><br><span class="line">        <span class="keyword">if</span> root_index != <span class="built_in">len</span>(inorder) - <span class="number">1</span>:</span><br><span class="line">            root.right = self.buildTree(preorder[root_index+<span class="number">1</span>:], inorder[root_index+<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            root.right = self.buildTree([], [])</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure> #### 从中序与后序遍历序列构造二叉树</p>
<p><strong>问题陈述</strong>：根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<p><strong>注意</strong>: 你可以假设树中没有重复的元素。</p>
<p>例如，给出 中序遍历 inorder = [9,3,15,20,7] 后序遍历 postorder = [9,15,7,20,3] 返回如下的二叉树：</p>
<p>3 /<br />
9 20 /<br />
15 7</p>
<p><strong>python递归</strong>实现： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, inorder: List[<span class="built_in">int</span>], postorder: List[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(inorder) == <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(postorder) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(inorder) == <span class="number">1</span> <span class="keyword">or</span> <span class="built_in">len</span>(postorder) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(inorder[<span class="number">0</span>])</span><br><span class="line">        root = TreeNode(postorder[-<span class="number">1</span>])</span><br><span class="line">        root_index = inorder.index(postorder[-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> root_index != <span class="number">0</span>:</span><br><span class="line">            root.left = self.buildTree(inorder[:root_index], postorder[:root_index])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            root.left = self.buildTree([], [])</span><br><span class="line">        <span class="keyword">if</span> root_index != <span class="built_in">len</span>(inorder) - <span class="number">1</span>:</span><br><span class="line">            root.right = self.buildTree(inorder[root_index+<span class="number">1</span>:], postorder[root_index:-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            root.right = self.buildTree([], [])</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure> #### 寻找重复子树</p>
<p><strong>问题陈述</strong>:给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。</p>
<p>两棵树重复是指它们具有相同的结构以及相同的结点值。</p>
<p>示例 1：</p>
<p>1 /<br />
2 3 / /<br />
4 2 4 / 4</p>
<p>下面是两个重复的子树：</p>
<p>2 / 4</p>
<p>和</p>
<p>4 因此，你需要以列表的形式返回上述重复子树的根结点。</p>
<p><strong>python</strong>实现： 每个节点为根的树进行序列化(使其成为字符串),利用节点所在树的字符串序列作为字典的键值，记录出现的值，如果值为2就将加入到结果序列。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findDuplicateSubtrees</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[TreeNode]:</span></span><br><span class="line">        result = []</span><br><span class="line">        count = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">collect</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: </span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span></span><br><span class="line">            <span class="comment"># serial = &quot;&#123;&#125;,&#123;&#125;,&#123;&#125;&quot;.format(root.val, collect(root.left), collect(root.right))</span></span><br><span class="line">            serial = <span class="string">&#x27;,&#x27;</span>.join([<span class="built_in">str</span>(root.val), collect(root.left), collect(root.right)])</span><br><span class="line">            count[serial] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count[serial] == <span class="number">2</span>:</span><br><span class="line">                result.append(root)</span><br><span class="line">            <span class="keyword">return</span> serial</span><br><span class="line">        collect(root)</span><br><span class="line">        <span class="comment"># for key in count.keys():</span></span><br><span class="line">        <span class="comment">#     print(key)</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure> #### 二叉树的序列化与反序列化</p>
<p><strong>问题陈述</strong>:序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p>
<p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>
<p>示例: </p>
<p>你可以将以下二叉树：</p>
<p>1 /<br />
2 3 /   4 5</p>
<p>序列化为 "[1,2,3,null,null,4,5]" 提示: 这与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p>
<p>说明: 不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。</p>
<ul>
<li><strong>关于实现</strong>：问题并不困难，按自己的方式将一棵二叉树扁平化并将扁平化的序列重新建立为二叉树即可。反思后认为这个题目挣扎了很久的重要原因是把自己困在了leetcode平台的序列化二叉树的格式上，被不重要的点牵住了鼻子。</li>
</ul>
<p><strong>python</strong>实现： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Encodes a tree to a single string.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment">## 层次遍历</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">        queue = []</span><br><span class="line">        queue.append(root)</span><br><span class="line">        position = <span class="number">0</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span>:</span><br><span class="line">            length = <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">                node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> node: </span><br><span class="line">                    res.append(<span class="string">&#x27;null&#x27;</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append(<span class="built_in">str</span>(node.val))</span><br><span class="line">                    <span class="keyword">if</span> node.left:</span><br><span class="line">                        queue.append(node.left)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        queue.append(<span class="literal">None</span>)</span><br><span class="line">                    <span class="keyword">if</span> node.right:</span><br><span class="line">                        queue.append(node.right)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        queue.append(<span class="literal">None</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;,&#x27;</span>.join(res)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Decodes your encoded data to tree.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        :type data: str</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span> </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">buildBinaryTree</span>(<span class="params">data</span>):</span></span><br><span class="line">        	<span class="comment">## 利用扁平化的序列建二叉树</span></span><br><span class="line">        	<span class="comment">## 借助队列存储二叉树的节点</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(data) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            queue = []</span><br><span class="line">            root = TreeNode(<span class="built_in">int</span>(data[<span class="number">0</span>]))</span><br><span class="line">            queue.append(root)</span><br><span class="line">            data.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(data) &gt; <span class="number">0</span>:</span><br><span class="line">                node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                node_left = data.pop(<span class="number">0</span>)</span><br><span class="line">                node.left = TreeNode(<span class="built_in">int</span>(node_left)) <span class="keyword">if</span> node_left != <span class="string">&#x27;null&#x27;</span> <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">                node_right = data.pop(<span class="number">0</span>)</span><br><span class="line">                node.right = TreeNode(<span class="built_in">int</span>(node_right)) <span class="keyword">if</span> node_right != <span class="string">&#x27;null&#x27;</span> <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">                queue.append(node.left)</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(data) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        data = data.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">        root = buildBinaryTree(data[:])</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># ser = Codec()</span></span><br><span class="line"><span class="comment"># deser = Codec()</span></span><br><span class="line"><span class="comment"># ans = deser.deserialize(ser.serialize(root))</span></span><br></pre></td></tr></table></figure> #### 二叉树的直径</p>
<p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点.</p>
<blockquote>
<p>注意：两结点之间的路径长度是以它们之间边的数目表示。</p>
</blockquote>
<p><strong>递归实现</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">depth</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    left = depth(root.left)</span><br><span class="line">    right = depth(root.right)</span><br><span class="line">    <span class="keyword">if</span> left &gt; right:</span><br><span class="line">        <span class="keyword">return</span> left + <span class="number">1</span> </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> right + <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">diameterOfBinaryTree</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    node = root</span><br><span class="line">    diameter = depth(root.left) + depth(root.right) + <span class="number">2</span></span><br><span class="line">    left_diameter = diameterOfBinaryTree(node.left)     </span><br><span class="line">    right_diameter = diameterOfBinaryTree(node.right)</span><br><span class="line">    child_diameter = left_diameter <span class="keyword">if</span> left_diameter &gt; right_diameter <span class="keyword">else</span> right_diameter</span><br><span class="line">    <span class="keyword">if</span> diameter &lt; child_diameter:</span><br><span class="line">        <span class="keyword">return</span> child_diameter</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> diameter</span><br></pre></td></tr></table></figure> #### 从根节点到目标结点的路径</p>
<p>给定二叉树的根节点和目标结点的值，以列表的形式返回从根节点到该节点的路径(要走的结点)。</p>
<blockquote>
<p>假设二叉树中所有结点的值都不相同</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeNode</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_exist</span>(<span class="params">root, data</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> root.data == data:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> is_exist(root.left, data) <span class="keyword">or</span> is_exist(root.right, data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">path_from_root_to_node</span>(<span class="params">root, data</span>):</span></span><br><span class="line">    path = []</span><br><span class="line">    <span class="keyword">if</span> root.data == data:</span><br><span class="line">        path.append(root.data)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> is_exist(root.left, data):</span><br><span class="line">            path.append(root.data)</span><br><span class="line">            path.extend(path_from_root_to_node(root.left, data))</span><br><span class="line">        <span class="keyword">elif</span> is_exist(root.right, data):</span><br><span class="line">            path.append(root.data)</span><br><span class="line">            path.extend(path_from_root_to_node(root.right, data))</span><br><span class="line">    <span class="keyword">return</span> path</span><br></pre></td></tr></table></figure>
<p>测试用例： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_arr_to_binary_tree</span>(<span class="params">arr</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Takes arr representing level-order traversal of Binary Tree </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    length = <span class="built_in">len</span>(arr)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> length &lt;= <span class="number">0</span> <span class="keyword">or</span> arr[<span class="number">0</span>] == -<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    root = BinaryTreeNode(arr[index])</span><br><span class="line">    index += <span class="number">1</span></span><br><span class="line">    queue = Queue()</span><br><span class="line">    queue.put(root)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> queue.empty():</span><br><span class="line">        current_node = queue.get()</span><br><span class="line">        left_child = arr[index]</span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> left_child <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            left_node = BinaryTreeNode(left_child)</span><br><span class="line">            current_node.left = left_node</span><br><span class="line">            queue.put(left_node)</span><br><span class="line">        </span><br><span class="line">        right_child = arr[index]</span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> right_child <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            right_node = BinaryTreeNode(right_child)</span><br><span class="line">            current_node.right = right_node</span><br><span class="line">            queue.put(right_node)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_function</span>(<span class="params">test_case</span>):</span></span><br><span class="line">    arr = test_case[<span class="number">0</span>]</span><br><span class="line">    data = test_case[<span class="number">1</span>]</span><br><span class="line">    solution = test_case[<span class="number">2</span>]</span><br><span class="line">    root = convert_arr_to_binary_tree(arr)</span><br><span class="line">    output = path_from_root_to_node(root, data)</span><br><span class="line">    print(output)</span><br><span class="line">    <span class="keyword">if</span> output == solution:</span><br><span class="line">        print(<span class="string">&quot;Pass&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&quot;Fail&quot;</span>)</span><br><span class="line"></span><br><span class="line">arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>]</span><br><span class="line">data = <span class="number">5</span></span><br><span class="line">solution = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">test_case = [arr, data, solution]</span><br><span class="line">test_function(test_case)</span><br><span class="line"></span><br><span class="line">arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="literal">None</span>, <span class="number">5</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>]</span><br><span class="line">data = <span class="number">5</span></span><br><span class="line">solution = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">test_case = [arr, data, solution]</span><br><span class="line">test_function(test_case)</span><br><span class="line"></span><br><span class="line">arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="literal">None</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="number">11</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>]</span><br><span class="line">data = <span class="number">11</span></span><br><span class="line">solution = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">11</span>]</span><br><span class="line"></span><br><span class="line">test_case = [arr, data, solution]</span><br><span class="line">test_function(test_case)</span><br><span class="line"></span><br><span class="line">arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="literal">None</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="number">11</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>]</span><br><span class="line">data = <span class="number">8</span></span><br><span class="line">solution = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>,<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">test_case = [arr, data, solution]</span><br><span class="line">test_function(test_case)</span><br></pre></td></tr></table></figure> ————</p>
<h4 id="折纸问题">折纸问题</h4>
<p>请把一张纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。 此时折痕是凹下去的。如果继续在刚刚的基础上再从下往上对折，展开后会有三条折痕。 从上到下依次为：凹、凹、凸。</p>
<p>给定一个输入参数N，代表纸条从下往上连续对折N次。请从上往下打印所有折痕的方向。</p>
<p>例如：N=1时，打印：down</p>
<p>N=2时，打印：down down up。</p>
<p>思路：左神在讲的时候画出了精髓的图如下，然后中序遍历这个在脑海中存在的二叉树。 <img src="/img/zhezhi.png" /></p>
<ul>
<li><strong>python实现</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printAllFolds</span>(<span class="params">N</span>):</span></span><br><span class="line">    printProcess(<span class="number">1</span>, N, <span class="literal">True</span>) <span class="comment">## 从第1层开始，总共N层，第一层处是凹(true)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## down为True是凹，False是凸</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printProcess</span>(<span class="params">i, N, down</span>):</span></span><br><span class="line">    <span class="keyword">if</span> i &gt; N:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    printProcess(i+<span class="number">1</span>, N, <span class="literal">True</span>)</span><br><span class="line">    print_value = <span class="string">&#x27;down&#x27;</span> <span class="keyword">if</span> down <span class="keyword">else</span> <span class="string">&#x27;up&#x27;</span></span><br><span class="line">    print(print_value)</span><br><span class="line">    printProcess(i+<span class="number">1</span>, N, <span class="literal">False</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">李子梅</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://lzmcosmos.github.io/2020/12/15/%E6%A0%91/">https://lzmcosmos.github.io/2020/12/15/%E6%A0%91/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%A0%91/">树</a><a class="post-meta__tags" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/">二叉树</a><a class="post-meta__tags" href="/tags/DFS%E4%B8%8EBFS/">DFS与BFS</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/12/16/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E7%9A%84%E6%A0%91/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">二叉搜索树及其相关的树</div></div></a></div><div class="next-post pull-right"><a href="/2020/12/15/python%E4%B8%AD%E7%9A%84%E8%B5%8B%E5%80%BC%E4%B8%8E%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">python中的赋值、深浅拷贝与函数传参</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div id="twikoo"></div></div></div></div></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/cosmos.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">李子梅</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">90</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">109</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">9</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/LZMcosmos"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/LZMcosmos" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:609792588@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">“莱布尼茨在他的二进位算术中看到了宇宙创始的原像。他想象1表示上帝，而0表示虚无，上帝从虚无中创造出所有实物，恰如在他的数学系统中用1和0表示了所有的数。”</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">1.</span> <span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E7%BB%93%E7%82%B9"><span class="toc-number">1.1.</span> <span class="toc-text">树的结点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E6%A0%91%E5%92%8C%E7%A9%BA%E6%A0%91"><span class="toc-number">1.2.</span> <span class="toc-text">子树和空树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E7%82%B9%E7%9A%84%E5%BA%A6%E5%92%8C%E5%B1%82%E6%AC%A1"><span class="toc-number">1.3.</span> <span class="toc-text">结点的度和层次</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%A0%91%E5%92%8C%E6%97%A0%E5%BA%8F%E6%A0%91"><span class="toc-number">1.4.</span> <span class="toc-text">有序树和无序树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%AE%E6%9E%97"><span class="toc-number">1.5.</span> <span class="toc-text">森林</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.</span> <span class="toc-text">二叉树定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">2.2.</span> <span class="toc-text">二叉树的性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.3.</span> <span class="toc-text">满二叉树和完全二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%94%9F%E6%88%90"><span class="toc-number">2.4.</span> <span class="toc-text">二叉树的生成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BB%93%E7%82%B9"><span class="toc-number">2.4.1.</span> <span class="toc-text">创建二叉树结点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E9%A2%97%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.4.2.</span> <span class="toc-text">创建一颗二叉树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">2.5.</span> <span class="toc-text">二叉树的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-number">2.5.1.</span> <span class="toc-text">深度优先搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">2.5.1.1.</span> <span class="toc-text">前序遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">2.5.1.2.</span> <span class="toc-text">中序遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86"><span class="toc-number">2.5.1.3.</span> <span class="toc-text">后续遍历</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-number">2.5.2.</span> <span class="toc-text">广度优先搜索</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BC%96%E7%A8%8B%E9%A2%98"><span class="toc-number">2.6.</span> <span class="toc-text">二叉树编程题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.6.1.</span> <span class="toc-text">翻转二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%98%E7%BA%B8%E9%97%AE%E9%A2%98"><span class="toc-number">2.6.2.</span> <span class="toc-text">折纸问题</span></a></li></ol></li></ol></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/03/16/mysql-select/" title="MySQL之基础查询与排序">MySQL之基础查询与排序</a><time datetime="2022-03-16T02:13:02.000Z" title="Created 2022-03-16 10:13:02">2022-03-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/03/13/Mysql%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E5%85%A5%E9%97%A8/" title="MySQL环境搭建与入门">MySQL环境搭建与入门</a><time datetime="2022-03-13T01:08:47.000Z" title="Created 2022-03-13 09:08:47">2022-03-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/11/01/CRF/" title="条件随机场（CRF）">条件随机场（CRF）</a><time datetime="2021-11-01T03:28:44.000Z" title="Created 2021-11-01 11:28:44">2021-11-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/07/14/%E5%AD%97%E7%AC%A6%E4%B8%B2/" title="字符串">字符串</a><time datetime="2021-07-13T16:30:25.000Z" title="Created 2021-07-14 00:30:25">2021-07-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/06/29/Heap/" title="堆">堆</a><time datetime="2021-06-29T04:45:04.000Z" title="Created 2021-06-29 12:45:04">2021-06-29</time></div></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/Nebula_planets-Universe.jpg)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 李子梅</div><div class="footer_custom_text">welcome to my <a href="https://lzmcosmos.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        addClass: [200,() => {
          document.querySelectorAll('mjx-container:not([display=\'true\']').forEach( node => {
            const target = node.parentNode
            if (!target.classList.contains('has-jax')) {
              target.classList.add('mathjax-overflow')
            }
          })
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>function loadTwikoo () {
  function init () {
    twikoo.init({ 
      envId: 'lzm-blog-8gx8fhrs09a28b34' 
    })
  }

  if (typeof twikoo.init === 'function') {
    init()
  } else {
    $.getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js', init)
  }
}

if ('Twikoo' === 'Twikoo' || !false) {
  if (false) btf.loadComment(document.getElementById('twikoo'), loadTwikoo)
  else loadTwikoo()
} else {
  function loadOtherComment () {
    loadTwikoo()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script>(function(){
  const bp = document.createElement('script');
  const curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https'){
  bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  bp.dataset.pjax = ''
  const s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})()</script></div></body></html>